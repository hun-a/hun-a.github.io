{"meta":{"title":"Dev Huna","subtitle":"Dev Huna's blog","description":"This is my personal blog about development","author":"Huna","url":"https://seunghun-kim.github.io"},"pages":[],"posts":[{"title":"hibernate 설정 + 간단 예제","slug":"hibernate_setting","date":"2017-11-17T00:00:00.000Z","updated":"2017-11-20T14:07:02.000Z","comments":true,"path":"2017/11/17/hibernate_setting/","link":"","permalink":"https://seunghun-kim.github.io/2017/11/17/hibernate_setting/","excerpt":"","text":"Hibernate 란?정의관계형 데이터베이스(RDBMS)와 객체지향 언어(Java)를 연결해주는 프레임워크이다. 주로 이런 애들을 ORM (Object/Relational Mapping) 프레임워크 라고 부른다. Node.js에서는 Sequelize 라는 놈이 있다. 특징 Object/Relational Mapping 말 그대로 객체/관계의 매핑을 제공한다. JPA Provider Java Persistance API를 구현하여 제공한다. 이를 통해 JPA를 지원하는 모든 환경에서 쉽게 사용할 수 있다. Idiomatic persistence 객체지향 패러다임에서 자연스럽게 Persistance class를 개발할 수 있게 도와준다. High Performance 개발자 생산성 및 런타임 측면에서 그냥 JDBC 코드를 쓴것보다 우수한 성능을 제공함. Scalability 어플리케이션이 서버 클러스터에서 작동하고 확장성이 뛰어난 아키텍처를 제공하도록 설계됨. Reliable 수많은 Java 개발자들이 사용하여 안전성 및 품질이 입증됨. Extensibility 설정과 확장이 쉬움 이정도 되겠다. 자 설정을 해보자우리는 Gradle 을 이용해서 의존성을 설정해 줄꺼다. 안그럼 넘넘넘넘넘나 번거롭다. 그리고 IDE는 Eclipse를 사용할 것이다. (무료니깐!) 설마 Eclipse를 모를 사람은 없을테니 자세한 설명은 생략한다. 다운은 여기에서 받도록.. Gradle은 모르는 사람이 있을 수도 있다. 하지만 나도 잘은 모른다. 그냥 라이브러리 갖다 쓸 수 있는 정도만 안다. 앞으로 더 알게되면 포스팅 하도록 하겠다. Gradle 다운은 여기에서 편한 방법으로 받으면 된다. 참고로 JDK 9 를 이용해서 했었는데 호환이 잘 안되는지 Eclipse와 Gradle 연동이 안됬었다. 그래서 JDK를 다시 8 버전대로 바꾸니깐 잘 됬었다. 참고하시길… 자 그럼 우린 JDK와 Eclipse, Gradle이 모두 준비 되었다. (벌써?) 나는 블로그에 그림 넣는걸 별로 안좋아한다. (절대 귀찮아서가 아니다 :( ) 따라서 커맨드 형식으로 보여주기 위해 프로젝트를 커맨드 형식으로 생성 후 Eclipse에서 import 하는 방식으로 진행할 것이다. Eclipse 프로젝트 생성먼저 프로젝트를 만들 적당한 곳으로 이동한다. 나는 ~/workspace/hibernate 이곳을 프로젝트 홈으로 만들 것이다. 12$ mkdir -p ~/workspace/hibernate$ cd ~/workspace/hibernate 그런 다음 gradle init --type java-library 이라고 명령어를 날려보자. 123456789101112131415$ gradle init --type java-libraryBUILD SUCCESSFUL in 1s2 actionable tasks: 2 executed$ ls -altotal 40drwxr-xr-x 9 hun staff 306 Nov 17 13:45 .drwxr-xr-x 3 hun staff 102 Nov 17 13:43 ..drwxr-xr-x 4 hun staff 136 Nov 17 13:43 .gradle-rw-r--r-- 1 hun staff 1031 Nov 17 13:43 build.gradledrwxr-xr-x 3 hun staff 102 Nov 17 13:43 gradle-rwxr-xr-x 1 hun staff 5296 Nov 17 13:43 gradlew-rw-r--r-- 1 hun staff 2260 Nov 17 13:43 gradlew.bat-rw-r--r-- 1 hun staff 584 Nov 17 13:43 settings.gradledrwxr-xr-x 4 hun staff 136 Nov 17 13:43 src 자 이제 build.gradle 파일을 열어서 java와 eclipse를 사용하겠다고 알려주자. apply plugin: &#39;java-library&#39; 부분 아래에 apply pulgin: &#39;eclipse&#39;를 추가하자. 123// Apply the java-library plugin to add support for Java Libraryapply plugin: &apos;java-library&apos;apply pulgin: &apos;eclipse&apos; // 여기! 이제 저장하고 나서 다시 프로젝트의 홈 디렉토리로 돌아가서 다음 명령어를 날려보자. 123456789101112131415161718$ gradle eclipseBUILD SUCCESSFUL in 1s3 actionable tasks: 3 executed$ ls -altotal 56drwxr-xr-x 12 hun staff 408 Nov 17 13:51 .drwxr-xr-x 3 hun staff 102 Nov 17 13:50 ..-rw-r--r-- 1 hun staff 3026 Nov 17 13:51 .classpathdrwxr-xr-x 4 hun staff 136 Nov 17 13:50 .gradle-rw-r--r-- 1 hun staff 383 Nov 17 13:51 .projectdrwxr-xr-x 3 hun staff 102 Nov 17 13:51 .settings-rw-r--r-- 1 hun staff 1055 Nov 17 13:51 build.gradledrwxr-xr-x 3 hun staff 102 Nov 17 13:50 gradle-rwxr-xr-x 1 hun staff 5296 Nov 17 13:50 gradlew-rw-r--r-- 1 hun staff 2260 Nov 17 13:50 gradlew.bat-rw-r--r-- 1 hun staff 584 Nov 17 13:50 settings.gradledrwxr-xr-x 4 hun staff 136 Nov 17 13:50 src 자, 이제 Eclipse 프로젝트가 생성이 되었다. ~(참 쉽죠?)~ Hibernate 추가이제, Eclipse로 돌아가서 File &gt; Import 를 클릭한 뒤, gradle &gt; Existing Gradle Project 를 선택하고 Next! How to experience the best blah blah blah~ 나오면 Next! Project root directory 부분에 우리가 만들었던 ~/workspace/hibernate 를 절대경로로 바꿔주고 난 뒤 Finish! 이제 Eclipse 프로젝트가 완성되었다. (왜케 힘들지? …) 하지만 우린 아직 갈길이 멀다. Eclipse에서 build.gradle 파일을 열어 몇가지 내용을 추가해주자. 현재 build.gradle 파일을 보면 3가지 섹션으로 나눠져 있는것을 알 수 있을 것이다. 첫 번째는 apply 가 적힌 부분! 내가 이런애들 쓸꺼야~ 라고 선언해주는 부분이다. 두 번째는 repositories 이 부분! 이 부분에서는 우리가 가져올 라이브러리들이 존재하는 경로를 알려주면 된다. Hibernate의 경우 Maven 리파지토리를 쓰면 된다. 마지막 세 번째는 dependencies 이 부분! 우리가 실제로 사용할 라이브러리들을 알려주는 부분이다. 여기에 적힌 라이브러리를 gradle이 보고, 자동으로 의존성을 확인해서 관련된 라이브러리들을 모~두 가져다 준다. (슈퍼 쿨!) 자 그럼 Hibernate를 추가해보자! 아래에 같이 build.gradle 파일을 수정한 뒤 저장해보자. 12345678910111213141516171819202122232425262728293031323334/* * This build file was generated by the Gradle &apos;init&apos; task. * * This generated file contains a sample Java Library project to get you started. * For more details take a look at the Java Libraries chapter in the Gradle * user guide available at https://docs.gradle.org/4.3.1/userguide/java_library_plugin.html */// Apply the java-library plugin to add support for Java Libraryapply plugin: &apos;java-library&apos;apply plugin: &apos;eclipse&apos;// In this section you declare where to find the dependencies of your projectrepositories &#123; // Use jcenter for resolving your dependencies. // You can declare any Maven/Ivy/file repository here. jcenter() mavenCentral() // maven 리파지토리를 추가해준다&#125;dependencies &#123; // This dependency is exported to consumers, that is to say found on their compile classpath. api &apos;org.apache.commons:commons-math3:3.6.1&apos; // This dependency is used internally, and not exposed to consumers on their own compile classpath. implementation &apos;com.google.guava:guava:23.0&apos; // Use JUnit test framework testImplementation &apos;junit:junit:4.12&apos; // hibernate 5.2.12 버전과 slf4j 라이브러리를 추가해준다. compile &apos;org.hibernate:hibernate-core:5.2.12.Final&apos; compile &apos;org.slf4j:slf4j-api:1.7.21&apos;&#125; 이제 hibernate를 사용할 준비가 완료되었다. 커맨드창으로 가서 gradle build 라고 했을때 오류 없이 잘 되면 성공한 것이다. (당연한 소릴 하네…) 1234$ gradle buildBUILD SUCCESSFUL in 4s4 actionable tasks: 4 executed CUBRID 추가나는 데이터베이스를 국산 오픈소스 DB인 CUBRID를 사용할 것이다. MySQL이나 다른 유명한 DB들은 검색하면 워낙에 많은 정보들이 나오니 다른거 쓰실 분들은 다른거 쓰셔도 된다. 이를 위해 우리는 repositories와 dependencies에 CUBRID 설정을 추가해야 한다. 다음처럼 추가해보자. 1234567891011121314151617181920212223242526272829repositories &#123; // Use jcenter for resolving your dependencies. // You can declare any Maven/Ivy/file repository here. jcenter() mavenCentral() // CUBRID를 위한 리파지토리 추가 maven &#123; url &apos;http://maven.cubrid.org/&apos; &#125; &#125;dependencies &#123; // This dependency is exported to consumers, that is to say found on their compile classpath. api &apos;org.apache.commons:commons-math3:3.6.1&apos; // This dependency is used internally, and not exposed to consumers on their own compile classpath. implementation &apos;com.google.guava:guava:23.0&apos; // Use JUnit test framework testImplementation &apos;junit:junit:4.12&apos; testImplementation &apos;org.hamcrest:hamcrest-all:1.3&apos; compile &apos;org.hibernate:hibernate-core:5.2.12.Final&apos; compile &apos;org.slf4j:slf4j-api:1.7.21&apos; // CUBRID를 사용하기 위한 추가! compile group: &apos;cubrid&apos;, name: &apos;cubrid-jdbc&apos;, version: &apos;10.1.0.7663&apos;&#125; hibernate의 경우 compile &#39;org.hibernate:hibernate-core:5.2.12.Final&#39; 이렇게 되 있는데 CUBRID는 왜 compile group: &#39;cubrid&#39;, name: &#39;cubrid-jdbc&#39;, version: &#39;10.1.0.7663&#39; 이렇게 되 있는지 궁금해 할 수 있겠다. 근데 별 차이 없다. hibernate 선언한 부분은 CUBRID 선언한 부분을 그저 짧게 작성한 것 뿐이다. :) 여기까지 하고 다시 커맨드로 가서 gradle build 를 입력해서 오류가 안난다면 성공이다. Hibernate 세팅이제 본격적인 Hibernate를 사용할 시간이다. 두근두근 하지 않는가? 자 먼저 Eclipse 프로젝트의 구조를 보면 다음과 같이 생겼을 것이다. (이미지를 넣을껄 그랬나?) 1234567891011hibernate `- src/main/java `- src/test/java `- JRE System Library [JavaSE-1.8] `- Project and External Dependencies `- gradle `- src `- build.gradle `- gradlew `- gradlew.bat `- settings.gradle 여기에 hibernate 설정 파일을 추가하기 위해 프로젝트명을 우클릭하여 new &gt; source folder 를 클릭한 뒤 src/main/resources 라고 생성해준다. 이제 방금 만든 src/main/resources 를 우클릭하여 new &gt; file 을 클릭한 뒤 hibernate.cfg.xml 이라는 파일을 생성해준다. 이 파일이 hibernate의 DB 접속 정보와 설정들, 그리고 매핑 클래스들 등 온갖 정보가 들어가게 된다. 우리는 아주 간단하게 만들 예정이니 참고하기 바란다. hibernate.cfg.xml 파일에 아래와 동일하게 입력한다. 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- Database connection properties - Driver, URL, user, password --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;cubrid.jdbc.driver.CUBRIDDriver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:cubrid:localhost:33000:demodb:public::&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;public&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;&lt;/property&gt; &lt;!-- Connection Pool Size --&gt; &lt;property name=\"hibernate.connection.pool_size\"&gt;1&lt;/property&gt; &lt;!-- Outputs the SQL queries, should be disabled in Production --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- Dialect is required to let Hibernate know the Database Type, MySQL, Oracle etc Hibernate 4 automatically figure out Dialect from Database Connection Metadata --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.CUBRIDDialect&lt;/property&gt; &lt;mapping class=\"dev.huna.model.Employee\"/&gt; &lt;mapping class=\"dev.huna.model.Address\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; &lt;session-factory&gt;에 있는 프로퍼티들 중 중요한 애들은 다음과 같다. hibernate.connection.driver_class: JDBC 드라이버가 로드될 때 필요한 클래스명을 알려주는 놈이다. hibernate.connection.url: JDBC Connection을 맺기 위한 url 접속 정보다. hibernate.connection.username: DB 사용자 이름이다. hibernate.connection.password: DB 사용자의 비밀번호이다. hibernate.connection.pool_size: Connection pool을 몇 개 사용할 것인지 설정이다. hibernate.show_sql: 이 값을 true로 설정하면 HQL이라는 Hibernate sql이 일반 SQL로 변환되어 로그로 출력된다. hibernate.dialect: 특정 DBMS에 맞게 설정된 클래스를 지정하는 부분인데 사실 4.대부터는 자동으로 잡아줘서 상관이 없긴 하다. 마지막으로 &lt;mapping&gt; 태그는 RDBMS의 테이블과 매핑시킬 클래스를 지정해 주는 것이다. 곧 Employee와 Address 클래스를 만들 것이다. 다 됬는가? 그럼 테이블을 먼저 준비해보자. Database 세팅먼저 table을 만들어보자. 간단한 Employee와 Address 이다. 123456789101112131415161718192021222324252627282930CREATE TABLE `Employee` ( `emp_id` int NOT NULL AUTO_INCREMENT, `emp_name` varchar(20) NOT NULL, `emp_salary` numeric(10,0) NOT NULL DEFAULT 0, PRIMARY KEY (`emp_id`));CREATE TABLE `Address` ( `emp_id` int NOT NULL, `address_line1` varchar(50) NOT NULL DEFAULT '', `zipcode` varchar(10) DEFAULT NULL, `city` varchar(20) DEFAULT NULL, PRIMARY KEY (`emp_id`), CONSTRAINT `emp_fk_1` FOREIGN KEY (`emp_id`) REFERENCES `Employee` (`emp_id`));INSERT INTO `Employee` (`emp_id`, `emp_name`, `emp_salary`)VALUES (1, 'Mr. Huna', 1000), (2, 'Miss A', 200), (3, 'Dr. strange', 300), (4, 'Jack and kong tree water', 400);INSERT INTO `Address` (`emp_id`, `address_line1`, `zipcode`, `city`)VALUES (1, 'devro 1-2', '95129', 'Developer Town'), (2, 'room 9', '95051', 'JYP'), (3, 'undefined', '560100', 'Marvel Universe'), (4, 'first street', '100100', 'Above the cloud'); Employee 와 Address는 foreign key로 연결되어 있고, 1:1 대응관계에 있다는 사실을 염두해두기 바란다. join을 구현하려면 이게 중요하다. Mapping class 작성방금 만든 두 개의 테이블에 대응하는 클래스를 각각 만들어야 한다. 매핑하는 방법은 xml을 이용하는 방법이 있고, annotation을 이용하는 방법이 있는데 여기서는 annotation을 이용하도록 하겠다. 클래스 이름은 알아보기 쉽게 테이블과 똑같이 만들어주자. dev.huna.model.Employee1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package dev.huna.model;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.OneToOne;import javax.persistence.Table;import javax.persistence.UniqueConstraint;@Entity@Table(name=\"EMPLOYEE\", uniqueConstraints=&#123;@UniqueConstraint(columnNames=&#123;\"EMP_ID\"&#125;)&#125;)public class Employee &#123; private int empId; private String empName; private int empSalary; private Address address; @Id @Column(name=\"EMP_ID\", nullable=false) @GeneratedValue(strategy=GenerationType.IDENTITY) public int getEmpId() &#123; return empId; &#125; public void setEmpId(int empId) &#123; this.empId = empId; &#125; @Column(name=\"EMP_NAME\", length=20, nullable=false) public String getEmpName() &#123; return empName; &#125; public void setEmpName(String empName) &#123; this.empName = empName; &#125; @Column(name=\"EMP_SALARY\", nullable=false) public int getEmpSalary() &#123; return empSalary; &#125; public void setEmpSalary(int empSalary) &#123; this.empSalary = empSalary; &#125; @OneToOne(mappedBy=\"employee\") public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"Employee [empId=\" + empId + \", empName=\" + empName + \", empSalary=\" + empSalary + \"]\"; &#125;&#125; dev.huna.model.Address12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package dev.huna.model;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.OneToOne;import javax.persistence.PrimaryKeyJoinColumn;import javax.persistence.Table;import javax.persistence.UniqueConstraint;@Entity@Table(name=\"ADDRESS\", uniqueConstraints=&#123;@UniqueConstraint(columnNames=&#123;\"EMP_ID\"&#125;)&#125;)public class Address &#123; private int empId; private String addressLine1; private String zipCode; private String city; private Employee employee; @Id @Column(name=\"EMP_ID\") public int getEmpId() &#123; return empId; &#125; public void setEmpId(int empId) &#123; this.empId = empId; &#125; @Column(name=\"ADDRESS_LINE1\") public String getAddressLine1() &#123; return addressLine1; &#125; public void setAddressLine1(String addressLine1) &#123; this.addressLine1 = addressLine1; &#125; @Column(name=\"ZIPCODE\") public String getZipCode() &#123; return zipCode; &#125; public void setZipCode(String zipCode) &#123; this.zipCode = zipCode; &#125; @Column(name=\"CITY\") public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; @OneToOne @PrimaryKeyJoinColumn public Employee getEmployee() &#123; return employee; &#125; public void setEmployee(Employee employee) &#123; this.employee = employee; &#125; @Override public String toString() &#123; return \"Address [empId=\" + empId + \", addressLine1=\" + addressLine1 + \", zipCode=\" + zipCode + \", city=\" + city + \"]\"; &#125;&#125; 다른 annotation들은 비교적 간단하나 개인적으로 JOIN에 사용되는 annotation이 난해했었다. 앞서 이야기한대로 1:1 대응관계이기 때문에 @OneToOne annotation을 사용하였다. 참고로 Employee 클래스의 @OneToOne의 mappedBy에는 Address 클래스의 employee를 멤버변수명을 써주면 되고 Address 클래스에서 Employee 클래스를 참조하는 경우에는 @PrimaryKeyJoinColumn annotation은 말 그대로 Primary key 이면서 join 컬럼으로 사용될 때 사용하면 되므로 요걸 사요하면 된다. (참 쉽죠?) Hibernate 연결 클래스Hibernate를 이용해서 DBMS에 접속하기 위해서는 먼저 Configuration 클래스를 만들어서 hibernate.cfg.xml 설정파일을 읽어들인 다음 SessionFactory 를 생성해내면 된다. 소스코드는 다음과 같다. dev.huna.util.HibernateUtil1234567891011121314151617181920212223242526package dev.huna.util;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; private static SessionFactory sessionFactory; private static SessionFactory buildSessionFactory() &#123; try &#123; Configuration configuration = new Configuration(); configuration.configure(\"hibernate.cfg.xml\"); return configuration.buildSessionFactory(); &#125; catch (Throwable ex) &#123; ex.printStackTrace(); throw new ExceptionInInitializerError(ex); &#125; &#125; public static SessionFactory getSessionFactory() &#123; if(sessionFactory == null) sessionFactory = buildSessionFactory(); return sessionFactory; &#125;&#125; Main 클래스이제 고지가 눈앞이다. 쫌만 힘내길 바란다. Main 클래스는 그냥 Hibernate를 이용해서 질의를 수행한다. 여기서는 간단히 HQL이라고 불리는 문법을 통해 질의를 수행해 볼 것이다. dev.huna.main.Main12345678910111213141516171819202122232425262728293031323334353637383940414243444546package dev.huna.main;import java.util.Arrays;import java.util.List;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.query.Query;import dev.huna.model.Employee;import dev.huna.util.HibernateUtil;public class Main &#123; public static void main(String[] args) &#123; SessionFactory sessionFactory = HibernateUtil.getSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); // Select all records at table of Employee Query query = session.createQuery(\"FROM Employee\"); List&lt;Employee&gt; empList = query.list(); for (Employee emp: empList) &#123; System.out.println(emp); &#125; // Select specific record at table of Employee query = session.createQuery(\"FROM Employee WHERE empId = :id\"); query.setParameter(\"id\", 1); Employee employee = (Employee) query.uniqueResult(); System.out.println(employee); // Inner join between Employee and Address query = session.createQuery(\"select e.empName, a.city, a.addressLine1 from Employee e INNER JOIN e.address a\"); List&lt;Object[]&gt; addrList = query.list(); for (Object[] arr: addrList) &#123; System.out.println(Arrays.toString(arr)); &#125; session.getTransaction().commit(); HibernateUtil.getSessionFactory().close(); &#125;&#125; 처음 질의 FROM Employee 는 Employee 테이블의 모든 데이터를 조회한다. 주의할 점은 Employee 는 Java 클래스를 의미하므로 첫 글짜가 Employee 클래스처럼 대문자로 적혀 있다. 궁금하면 FROM employee 로 수정해서 돌려보길 바란다. Exception이 후두두두둑 떨어질 것이다. 두 번째 질의는 파라미터를 바인딩 하는 예제이다. JDBC의 prepare, setXXX 이런 애들과 동일하다. 여기서 또 주의해야 할 점은 WHERE empId 에서 empId 는 Employee 클래스의 empId 멤버변수를 의미한다. 대소문자 주의하기 바란다. 아! 바인딩 할때 :id 와 같이 임의로 이름을 정해준 뒤 query.setParameter(변수명, 값) 형태로 바인딩하면 된다. JDBC 드라이버에 비해 굉장히 추상적이라서 맘에 든다. (setObject() 도 비슷하긴 하지만… 그래도…) 마지막 예제는 Employee 클래스와 Address 클래스의 INNER JOIN 예제이다. Employee 클래스에서 address 라는 멤버변수를 생성했던걸 기억하는가? HQL 내부의 e.address 는 바로 그 멤버변수를 가리키는 것이다. Hibernate 는 질의도 객체지향적이다! (슈퍼 쿨!) join의 경우 결과값이 Object[]로 생성됨을 유의하자. 휴, 드디어 끝났다. 실행은 각자 해보길 바란다.","categories":[{"name":"Java","slug":"Java","permalink":"https://seunghun-kim.github.io/categories/Java/"},{"name":"Libraries","slug":"Java/Libraries","permalink":"https://seunghun-kim.github.io/categories/Java/Libraries/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://seunghun-kim.github.io/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://seunghun-kim.github.io/tags/Hibernate/"}]},{"title":"Euclidean_algorithm","slug":"Euclidean_algorithm","date":"2017-11-15T03:20:56.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2017/11/15/Euclidean_algorithm/","link":"","permalink":"https://seunghun-kim.github.io/2017/11/15/Euclidean_algorithm/","excerpt":"","text":"잡담원래 github pages와 jekyll을 이용해서 블로그를 운영하다가 잠시 tistory로 옮겼다가 이번에 hexo를 이용해서 다시 github pages로 돌아왔다. 이게 뭐하는거? 이 글은 예전에 tistory에 포스팅 했던건데 이리로 옮겨온 것이다. 그럼 본론으로 들어가 보자. 소개최대 공약수를 구할 수 있는 파워풀한 알고리즘은 유클리드 호제법 에 대해 알아보도록 하겠다. 이리 좋은걸 왜 우리는 학교에서 안배운걸까? 안타깝다. 내딸은 아직 6개월뿐이 안됬지만 나중에 내가 가르쳐야겠다 ㅋㅋ 정의유클리드 호제법의 정의는 다음과 같다. 두 양의 정수 a, b (b &gt; a) 에 대해 b = aq + r (0 &lt;= r &lt; q) 라 하면gcd(a, b) = gcd(a, r)이 성립한다. 즉, a, b의 최대 공약수는 a, r의 최대 공약수와 같다는 말이다. (왜?) 자 그럼 왜 그런지 증명을 해보자. gcd(a, b) = G 라고 하고, 서로소 A, B에 대해 다음과 같은 식이 성립된다.a = GA, b = GB 유클리드 호제법 정의의 b = aq + r 에 위의 수식을 대입하면GB = GAq + r 이고 이를 이항 후 G로 묶으면r = G(B - Aq) 가 성립한다.유클리드 호제법의 정의에 따르면 gcd(a, b) = gcd(a, r) = G 가 된다.a = GA이고, r = G(B - Aq) 이므로A와 B - Aq가 서로소이면 증명이 끝난다. gcd(A, B - Aq) = m 이라고 가정하고 이를 만족하는 적당한 서로소를 k, l 이라고 해보자.그럼 A = mk, B - Aq = ml 이 성립한다.B = Aq + ml 이고, A = mk 이므로 B = mkq + ml = m(kq + l) 이 성립한다.즉, B = m(kq + l) 이므로 m은 A와 B의 공약수이다. 하지만 맨 위에서 A와 B는 서로소라고 했으니 m = 1 이되므로A와 B - Aq 역시 서로소가 된다. 따라서 gcd(a, b) = gcd(a, r) 이 성립된다. 증명 끝! 굉장했다. 증명은 나무위키에서 보고 참고했다. 실제 알고리즘은 위에 증명에 비하면 너무너무너무 간단하다. b = aq + r (0 &lt;= r &lt; q) 만 이용하면 된다. 48, 60 을 가지고 구해보자. b = aq + r 을 이용하여60 = 48 x 1 + 1248 = 12 x 4 + 0 음?! 너무 간단하게 나왔다. 12가 최대 공약수임을 알았다. 다시, 좀 더 복잡한 95, 250 을 가지고 해보자. 250 = 95 x 2 + 6095 = 60 x 1 + 3560 = 35 x 1 + 2535 = 25 x 1 + 1025 = 10 x 2 + 510 = 5 x 2 + 0 최대 공약수는 5가 되겠다. 이제 위 과정을 일반화를 통해 알고리즘을 구현해 보자. gcd(95, 250)에서 a = 95, b = 250 이다. 250 % 95 -&gt; 60 이므로 r = 60 이 된다. 즉, gcd(95, 250) = gcd(95, 60) 과 같다. 근데, (60, 95) 에 대한 최대 공약수나, (95, 60) 에 대한 최대 공약수나 똑같다. gcd(95, 60) 이나 gcd(60, 95)나 똑같다는 의미이다. 그럼, 다음 식을 보자. gcd(60, 95) 에서 a = 60, b = 95 이다. 95 % 60 -&gt; 35 이므로 r = 35 이다. 즉, gcd(60, 95) = gcd(60, 35) = gcd(35, 60) 이다. 다음 식은 60 % 35 -&gt; 25 이므로 gcd(35, 60) = gcd(35, 25) = gcd(25, 35) 이고, 35 % 25 -&gt; 10 이므로 gcd(25, 35) = gcd(25, 10) = gcd(10, 25) 이고… 25 % 10 -&gt; 5 이므로 gcd(10, 25) = gcd(10, 5) = gcd(5, 10) 이고 10 % 5 -&gt; 0 이므로 최대 공약수는 5 가 된다. 요약하면 gcd(95, 250) = gcd(5, 10) 과 같은 것이다. 그럼, 위 과정을 일반화 해서 보면 gcd(a, b) 는 다음 단계에서 gcd(b %a, a) 가 된다는 걸 알 수 있다. 하지만 b % a 가 0일 경우, 우리는 최대 공약수를 찾았으므로 a 를 반환하면 된다. 구현해보자! JavaScript123const eu = function(a, b) &#123; return b % a ? eu(b % a, a) : a;&#125; Java123public int eu(int a, int b) &#123; return b % a != 0 ? eu(b % a, a) : a;&#125; 참고로 최소 공배수는 유클리드 호제법을 안다면 굉장히 간단하게 구할 수 있다. lcd(a, b) = a * b / gcd(a, b) 이다. 직접 구현해보기 바란다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://seunghun-kim.github.io/categories/Algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://seunghun-kim.github.io/tags/Algorithms/"},{"name":"Euclidean","slug":"Euclidean","permalink":"https://seunghun-kim.github.io/tags/Euclidean/"}]},{"title":"print_star (2)","slug":"print_star_02","date":"2017-10-19T14:00:00.000Z","updated":"2017-11-15T16:11:16.000Z","comments":true,"path":"2017/10/19/print_star_02/","link":"","permalink":"https://seunghun-kim.github.io/2017/10/19/print_star_02/","excerpt":"","text":"지난번 작성한 포스팅에 이어서 새로운 알고리즘으로 문제를 풀어보기로 했다. 지난번 내용이 궁금하면 여기를 통해 확인하기 바란다. 해당 포스팅 내용으로 저작권 문제가 발생할 경우 글을 삭제하도록 하겠습니다. :) 이 포스팅은 누구에게 보여주기가 아닌 내가 그냥 정리하는 수준이므로 소스코드가 자세하게 나와있지 않다. 고 이전 포스팅에도 말했었다.참고하기 바란다. ;) 자 그럼 이번에는 이진 트리가 아닌 동적 프로그래밍 기법을 통해서 문제를 풀어보자. 문제문제는 다음과 같다. 입력: 첫째 줄에 N이 주어진다. N은 항상 3*2^k 수이다. (3, 6, 12, 24, 48, …) (k &lt;= 10)출력: 첫째 줄부터 N번째 줄까지 별을 출력한다. 만약 24를 입력했다면 다음과 같은 별들이 이쁘게 찍힌다. 123456789101112131415161718192021222324 * * * ***** * * * * * * ***** ***** * * * * * * ***** ***** * * * * * * * * * * * * ***** ***** ***** ***** * * * * * * ***** ***** * * * * * * * * * * * * ***** ***** ***** ***** * * * * * * * * * * * * ***** ***** ***** ***** * * * * * * * * * * * * * * * * * * * * * * * ****** ***** ***** ***** ***** ***** ***** ***** 유레카! 위 그림을 자세히 보면 123 * * ****** 이런 별모양이 계속 반복해서 나타난다는 것을 알 수 있다. 바로 이거다! 동적 프로그래밍!! Dynamic Programming!!!!!! 커다란 별모양을 잘 살펴봤더니 작은 별모양들이 보인다! 작은 별모양을 하나씩 만들어서 저장 해놓고 필요할때 저장된 별모양을 꺼내서 사용하면 이게 바로 동적 프로그래밍!! Dynamic Programming!!!!!! 너무 오바했다. 아무튼 저런 방식으로 구현을 해볼까 한다. 풀이이번에도 Coordinate 클래스가 필요하다. 12345class Coordinate &#123; public int x; public int y; ...&#125; 이 클래스는 오늘도 별모양을 만들 시작 좌표를 저장할 클래스이다. 이 클래스에는 left, right 라는 메소드가 있는데 k의 값을 기준으로 x, y 좌표가 얼마씩 증가될 것인지를 생성해낸다. left일 경우는 왼쪽 별을 그릴때, right의 경우는 오른쪽 별을 그릴때가 되겠다. 예를 그림으로 한번 보면 k = 1 일 경우 N은 6이 되므로 다음과 같은 별모양이 찍혀야 한다. 123456 * * * ***** * * * * * ****** ***** 위 별모양을 만들기 위해 아래 별모양의 모든 좌표들을 (x - 3, y + 3) 로 똑같이 복사하면 123 * * ****** 아래와 같은 별모양이 된다. 123456 * * * ***** * * ****** 오! 그럼 (x + 3, y + 3)으로도 복사하면!!! 다음과 같이 우리가 원하는 별모양이 완성된다. 123456 * * * ***** * * * * * ****** ***** 이게 k = 1일 경우이다. 만약 k = 2일 경우 위의 별들의 좌표를 전부 (x - 6, y + 6)과 (x + 6, y + 6) 만큼 복사해주면 아래와 같이 N이 12일 경우의 별모양이 찍히게 된다. 123456789101112 * * * ***** * * * * * * ***** ***** * * * * * * ***** ***** * * * * * * * * * * * ****** ***** ***** ***** k = 3일 경우 위의 별모양을 (x - 12, y + 12), (x + 12, y + 12) 위치로 각각 복사해주면 N이 24일 경우의 별모양이 나온다. 이 그림은 본 포스트 맨 위에 문제 설명부분을 참고하면 되겠다. 자 그럼 전체적인 알고리즘을 알아보자. N을 입력 받는다. 이 N을 통해서 k의 값을 생성해낸다. 별들의 시작 좌표를 저장할 Coordinate[] coordinateSet 배열을 생성한다. 배열의 크기는 별 6개짜리 젤 작은 별들 전체의 개수가 저장될 것이다. 그 값은 k = 0일 경우 1, k &gt; 0 일 경우 3 * 3^(k - 1) 이 된다. 전체 별모양을 저장할 2차원 char 배열을 생성한다. x좌표 전체의 크기 (totalWidth라고 하자)인 (6 * 2^k) - 1이 된다. 즉, char[][] canvas = new char[N][totalWidth] 가 된다. 맨 처음 제일 꼭대기에 있는 별의 좌표를 알아낸다. (totalWidth / 2, 0)이 된다. 이 값을 coordinateSet[0]에 넣어준다. 이제 시작!! 맨 초기에는 coordinateSet에 값이 1개뿐이 없으므로 pointer를 1로 지정해준다. 이 pointer는 앞으로 새로운 별들이 복사될 위치를 기억하게 될 것이다. 이제 loop를 돌자. 0부터 k 전까지 쭉 돌자. 왜냐면 우리는 k번만큼 별을 복사하면 되기 때문이다. 왼쪽 오른쪽으로 별들을 복사해야 한다. 이걸 판단하려면 loop 처음에 pointer를 임시 변수에 저장해야한다. pointer 변수는 loop를 돌면서 변경되기 때문이다. 복사된 변수는 loopCount라고 해보자. 0부터 loopCount 전까지 루프를 돌면 지금까지 coordinateSet에 저장된, 즉 k - 1번째까지 생성된 coordinate들에 접근할 수 있다. 이 값들을 coordinateSet[pointer++]에다가 복사될 위치를 계산해서 저장해주면 왼쪽, 오른쪽 별그림들을 모두 복사할 수 있다. coordinateSet을 모두 순회하면서 coordinate 값을 통해 별을 canvas[][] 변수에 그려준다. 출력하면 이쁘게 별들이 나온다. 말로만 설명하려니 하는 나도 답답하고 보는 사람은 더 죽을맛일 것이다. (이게 무슨 멍멍이소리야! 이럴 지도…) 4번부터 9번까지 소스코드를 첨부하면 다음과 같다. 12345678910111213Coordinate startCoordinate = new Coordinate(totalWidth / 2, 0);coordinateSet[0] = startCoordinate;int pointer = 1;for (int i = 0; i &lt; level; i++) &#123; int loopCount = pointer; for (int j = 0; j &lt; loopCount; j++) &#123; coordinateSet[pointer++] = coordinateSet[j].left(i); &#125; for (int j = 0; j &lt; loopCount; j++) &#123; coordinateSet[pointer++] = coordinateSet[j].right(i); &#125;&#125; coordinateSet[j].left(i), coordinateSet[j].right(i) 는 무엇이냐! 다음과 같다. 123456789101112131415class Coordinate &#123; int x; int y; ... public Coordinate left(int level) &#123; int increment = (int)(3 * Math.pow(2, level)); return new Coordinate(this.x - increment, this.y + increment); &#125; public Coordinate right(int level) &#123; int increment = (int)(3 * Math.pow(2, level)); return new Coordinate(this.x + increment, this.y + increment); &#125;&#125; 이 부분은 k에 따라 얼만큼 위치로 별들을 복사할지 설정하는 메소드이다. 자 이제 별들의 시작 좌표가 coordinateSet이라는 배열에 모두 저장되었다. 이 배열을 순회하면서 canvas 변수에 실제 별들의 위치에 * 을 그려주면 된다. 마지막으로 한가지 팁! 별을 출력할때 매번 System.out.println()을 이용해서 출력하면 굉~~~~~장한 성능 저하가 발생한다. System.out.println()이 호출될때 마다 Java application이 block되므로 가능한 적게 호출하도록 해보자. 나는 canvas에 저장된 char 값들을 모두 StringBuilder에 append()해서 한방에 System.out.println()으로 출력했다. (사실 이렇게 안하고 건건히 System.out.println()으로 했다가 시간 초과로 틀렸었다…) 그럼 즐거운 코딩 하세요~","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://seunghun-kim.github.io/categories/Algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://seunghun-kim.github.io/tags/Algorithms/"},{"name":"Star","slug":"Star","permalink":"https://seunghun-kim.github.io/tags/Star/"}]},{"title":"print_star (1)","slug":"print_star_01","date":"2017-10-19T14:00:00.000Z","updated":"2017-11-15T15:50:07.000Z","comments":true,"path":"2017/10/19/print_star_01/","link":"","permalink":"https://seunghun-kim.github.io/2017/10/19/print_star_01/","excerpt":"","text":"백준 온라인 저지에는 다양한 알고리즘 문제들이 많이 있다. 그 중에서 별찍기-11 (2448번) 문제에 대해 포스팅하려고 한다. 해당 포스팅 내용으로 저작권 문제가 발생할 경우 글을 삭제하도록 하겠습니다. :) 이 포스팅은 누구에게 보여주기가 아닌 내가 그냥 정리하는 수준이므로 소스코드가 자세하게 나와있지 않다. 참고하기 바란다. 문제문제는 다음과 같다. 입력: 첫째 줄에 N이 주어진다. N은 항상 3*2^k 수이다. (3, 6, 12, 24, 48, …) (k &lt;= 10)출력: 첫째 줄부터 N번째 줄까지 별을 출력한다. 만약 24를 입력했다면 다음과 같은 별들이 이쁘게 찍힌다. 123456789101112131415161718192021222324 * * * ***** * * * * * * ***** ***** * * * * * * ***** ***** * * * * * * * * * * * * ***** ***** ***** ***** * * * * * * ***** ***** * * * * * * * * * * * * ***** ***** ***** ***** * * * * * * * * * * * * ***** ***** ***** ***** * * * * * * * * * * * * * * * * * * * * * * * ****** ***** ***** ***** ***** ***** ***** ***** 첫 번째 알고리즘맨 처음 이 문제를 보고 어떻게 구현할지 고민하다가번뜩 떠오른게 바로 이진트리 였다. 아래 모양을 하나의 노드로 보고 123 * * ****** 좌측, 우측 노드를 연결해 나가면 저런 모양이 만들어 지겠구나! 라고 생각하며 유레카! 를 외쳤다. 먼저 트리형태로 저장할 StarNode 클래스와 별의 시작 좌표값을 저장할 Coordinate 클래스를 만들었다. 123456789101112class StarNode implements Cloneable &#123; Coordinate startCordinate; StarNode left; StarNode right; ... &#125;class Coordinate &#123; public int x; public int y; ...&#125; StarNode 클래스는 좌측, 우측 자식노드를 생성할 때 자기 자신을 복제해서 갖다 붙히려고 Cloneable 인터페이스를 구현했다. 물론 clone 할때 재귀적으로 내부의 모든 노드들을 복사해줘야 하는 문제가 있어서 귀찮긴 했다. 그럴땐 재귀 재귀 재귀…!!!! (훗날 커다란 성능이슈가…) 일단 전체적인 알고리즘을 서술하면 다음과 같다. Input으로 N 값을 입력받고, N을 통해서 k의 값을 알아낸다. (코드상의 k는 0부터 시작하기로 정했다) k를 통해 별 그림을 저장할 2차원 char 배열의 가로 길이를 생성한다. (6*2^k) - 1 이 되며 편의상 row라고 부르자. input과 row를 통해 2차원 char 배열을 초기화 한다. char[][] canvas = new char[input][row] 가 되겠다. 이진트리의 root 노드를 생성한다. 이 노드가 저장할 좌표(coordinate)는 가장 위의 별 좌표이므로 (row / 2, 0) 이 된다. 이제 root노드를 이용해서 k번 루프를 돌면서 자식 노드들을 생성한다. 자식 노드는 root를 그대로 복사해서 root의 가장 왼쪽 리프노드와 가장 오른쪽 리프노드로 붙혀주면 된다. 이걸 k번 반복하면 이쁜 이진트리가 생성된다. 이진트리가 모두 생성됬으면 root 노드의 coordinate값을 이용해서 모든 자식노드의 coordinate를 생성한다. coordinate는 좌측 자식노드는 부모 coordinate 값이 (x - 3, x + 3)으로, 우측의 경우는 (x + 3, y + 3)이 된다. 각 트리를 순회하면서 coordinate 값을 통해 위에서 만든 canvas 2차원 배열에 * 모양들을 찍는다. 다시 말하지만 coordinate는 별이 그려질 시작 좌표만을 저장하고 있는 값이다. 자 이제 끝났다. 출력을 해보자. 오… 별모양이 위에 그림들처럼 이쁘게 잘 찍힌다. 물론 처음 소스코드 작성했다고 바로 결과가 나오진 않았고… 여러번 손을 봤다. ;) 첫 번째 알고리즘 완료!이제 다 만들어진 소스코드를 백준 온라인 저지에 제출해보자! 그 결과…!!!! 재귀를 남발한 그 결과…!!! 시간초과!!!! 아… ㅋㅋㅋㅋㅋㅋ input이 200이 되는 순간…. 응답이 없다… 넘 느리다… 아… ㅋㅋㅋㅋㅋㅋ 재귀를 모두 loop로 바꿔봐야겠다. 라고 생각 했으나 새로운 알고리즘을 생각해보기로 결정했다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://seunghun-kim.github.io/categories/Algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://seunghun-kim.github.io/tags/Algorithms/"},{"name":"Star","slug":"Star","permalink":"https://seunghun-kim.github.io/tags/Star/"}]},{"title":"Node.js events (1)","slug":"node-events-01","date":"2017-04-24T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2017/04/25/node-events-01/","link":"","permalink":"https://seunghun-kim.github.io/2017/04/25/node-events-01/","excerpt":"","text":"잡담Node.js의 특징인 Event driven과 Asynchronous를 잘 활용을 못하고 있는 것 같아서 Node.js의 매뉴얼 중 Events 항목을 한번 자세히 읽어 보기로 했다. 문서의 버전은 17-04-25 기준 최신인 v7.9.0 이다. 그럼 하나씩 훑어보자. 아니 자세히 보자. 영어 실력이 개판이니 내맘데로 번역해도 이해해주시기 바랍니다 :) Events매뉴얼을 들어가면 초록색 박스에 Stability:2 - Stable 이라고 되어 있다. 이 부분은 매뉴얼의 Stability Index 항목을 참고하면 된다. 간단하게 설명 하자면 Stability: NUMBER 에서 NUMBER 가 높을수록 안정된 API라는 의미이다. 사실 색상만 봐도 안정됬는지 안됬는지 알 수 있다. 0은 deprecated, 1 은 Experimental, 2는 stable 을 가리킨다. 다시, Events가 무엇인가? 많은 Node.js 코어 API들의 객체 내부에는 비동기적 이벤트 주도 아키텍쳐 로 작성이 되어 있는데, emitters 라고 불리는 이러한 객체들이 주기적으로 events 이름을 호출하고 이를 통해 Function 객체들이 호출되게 된다.무슨 말인지 안다면 당신은 이미 Node.js를 많이 알고 있는 고수일 것이다. 예를 보자. net.Server 객체에서는 peer가 접속을 할 때 마다 event를 emit 한다. fs.ReadStream 객체에서는 파일이 열리면 event를 emit 한다. stream 객체에서는 data가 읽을 준비가 되면 event를 emit 한다. 즉, 해당 객체에서 처리해야 할 일이 준비가 되거나, 수행하게 되면 evnet를 emit, 간단하게 말하면 나 작업 (준비 혹은 완료) 다 됬어~ 라고 알려준다. events를 emit 하는 모든 객체들은 EventEmitter 클래스의 인스턴스이다. 이러한 객체들은 EventEmitter.on() 함수를 통해 하나 이상의 함수를 해당 객체에 의해 생성된 events에다가 갖다 붙힐 수 있게 해준다. 아니, listeners로 등록할 수 있게 해준다.event 이름은 camel-cased로 작성하는게 전형적인 방법 이지만 javascript의 property의 정상적인 key 값이면 사용할 수 있다. 그래서 event 이름을 Hi-Man 이라고 해봤는데 잘 작동 했다. EventEmitter 객체가 event를 emit하면 해당 이벤트에 연결된 모든 함수들이 동기적으로 수행된다. 그리고 호출된 listeners가 리턴한 값들은 무시된다. 무슨 이야기지? listeners? 일단 매뉴얼을 더 보도록 하자. 드디어 예제가 나왔다. 1개의 listeners를 가진 EventEmitter 인스턴스라는데 소스를 보면 좀 이해가 되지 않을까 싶다. 자 여기서! EventEmitter의 동작 방식을 설명해주고 있다. 12The eventEmitter.on() method is used to register listeners,while the eventEmitter.emit() method is used to trigger the event. 즉, eventEmitter.on() 메소드는 listeners를 등록하는데 사용되고,eventEmitter.emit() 메소드는 해당 event를 작동시키는 trigger 로 사용된다.소스코드는 아래와 같다. 123456789const EventEmitter = require('events');class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; &#123; console.log('an event occurred!');&#125;);myEmitter.emit('event'); 최신 Node.js라서 그런지 ES6의 문법들로 작성이 되어 있다. 굉장히 보기 좋다. 소스를 보면, myEmitter.on()을 통해 console.log(&#39;an event occurred!&#39;) 를 출력하는 이벤트를 listeners로 등록했다. 그리고 맨 마지막에 eventEmitter.emit()을 통해 위의 listeners로 등록된 이벤트를 동작시키고 있다. 결과는 당연히 an event occurred! 가 콘솔에 찍힐 것이다. listeners에 파라미터와 this 전달하기eventEmitter.emit() 메소드는 파라미터를 임의로 전달 할 수 있도록 허락한다. 즉, 파라미터를 보내도 그만, 안보내도 그만이다. 하지만 여기서 기억해야 할 중요한 사항이 있는데, 평범한 listeners 함수가 eventEmitter에 의해 호출될 때, this 키워드는 의도적으로 listeners가 부착된 eventEmitter 클래스를 참조하게 된다. 말로만 봐서는 잘 모르겠으니 예제를 보자. 123456const myEmitter = new MyEmitter();myEmitter.on('event', (a, b) =&gt; &#123; console.log(a, b, this); // Prints: a b &#123;&#125;&#125;);myEmitter.emit('event', 'a', 'b'); console.log(a, b, this)가 출력되면 this 는 무엇을 참조할까? 우리는 위에서 그 해답을 봤었다. 바로 myEmitter 를 참조한다. 꼭 기억해서 헷갈리지 않기를! 라고 말 했지만 사실 myEmitter는 객체이고, on()은 메소드이니 this가 myEmitter를 참조하는건 당연한 것이다. 매뉴얼 오바하긴… Asynchronous vs. SynchronousEventEmitter 는 모든 listeners를 등록된 순서대로 동기적으로 호출한다. 이를 통해 이벤트의 적절한 순서와 race conditions 또는 로직 에러를 피할 수 있게 보장한다.하지만 setImmediate() 또는 process.nextTick() 메소드를 통해서 listeners 함수를 Asynchronous 모드로 바꿀 수 있다. 1234567const myEmitter = new MyEmitter();myEmitter.on('event', (a, b) =&gt; &#123; setImmediate(() =&gt; &#123; console.log('this happens asynchronously'); &#125;);&#125;);myEmitter.emit('event', 'a', 'b'); 위 소스만 봐서는 정말로 Asynchronous 모드로 동작 하는지 잘 모르겠다. 소스코드를 좀 수정해서 돌려보자. 123456789const myEmitter = new MyEmitter();myEmitter.on('event', (a, b) =&gt; &#123; setImmediate(() =&gt; &#123; console.log('this happens asynchronously'); &#125;);&#125;);console.log('before emit');myEmitter.emit('event', 'a', 'b');console.log('after emit'); 실행 결과는 다음과 같다. 123before emitafter emitthis happens asynchronously 그럼 setImmediate() 없이 수행하면 어떻게 될까? 이렇게 나온다. 123before emitthis happens asynchronouslyafter emit 와우! lol events 를 딱 한번만 처리하기위에서 listeners 등록할 때 on() 메소드를 사용했는데 이거 말고 once() 라는 메소드를 쓰면 아무리 emit()을 해도 딱 한 번만 호출되고 해당 listeners가 제거되어 버린다. 예제는 아래와 같다. 123456789const myEmitter = new MyEmitter();let m = 0;myEmitter.once('event', () =&gt; &#123; console.log(++m);&#125;);myEmitter.emit('event');// Prints: 1myEmitter.emit('event');// Ignored Error eventsEventEmitter 인스턴스에서 error가 발생하면, 보통은 error event를 emit 하게 만든다. 만약에 EventEmitter에 error 관련 listeners가 하나도 등록이 되어 있지 않는데 error가 emit 되면 어떻게 될까? error 가 던져지고, stack trace가 출력되고, Node process가 죽어버린다. 123const myEmitter = new MyEmitter();myEmitter.emit('error', new Error('whoops!'));// Throws and crashes Node.js 이를 방지하려면 3 가지 방법이 있다. process 객체에 uncaughtException으로 listeners를 등록한다. domain 모듈을 사용한다 - deprecated 해당 객체에 항상 error를 listeners를 등록한다. - BEST! 12345678const myEmitter = new MyEmitter();process.on('uncaughtException', (err) =&gt; &#123; console.error('whoops! there was an error');&#125;);myEmitter.emit('error', new Error('whoops!'));// Prints: whoops! there was an error 이거 보다는 123456const myEmitter = new MyEmitter();myEmitter.on('error', (err) =&gt; &#123; console.error('whoops! there was an error');&#125;);myEmitter.emit('error', new Error('whoops!'));// Prints: whoops! there was an error 이렇게 쓰자.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://seunghun-kim.github.io/categories/JavaScript/"},{"name":"Node.js","slug":"JavaScript/Node-js","permalink":"https://seunghun-kim.github.io/categories/JavaScript/Node-js/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://seunghun-kim.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://seunghun-kim.github.io/tags/nodejs/"},{"name":"events","slug":"events","permalink":"https://seunghun-kim.github.io/tags/events/"}]},{"title":"javascript game (6)","slug":"js-game-06","date":"2017-04-23T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2017/04/24/js-game-06/","link":"","permalink":"https://seunghun-kim.github.io/2017/04/24/js-game-06/","excerpt":"","text":"잡담어느덧 절반 이상 만들었다. 오늘 포스팅까지 구현하면 이제 그럴듯한 게임이 만들어 질 것이다. 그러니 나머지 부분도 잘 따라오기 바란다. 지난 포스팅이 궁금하면 다음 아래 링크를 참고하기 바란다. 캔버스 생성과 그리기 공 움직이기 벽에 공 튀기기 판때기 구현과 키보드 컨트롤 Game Over 벽돌 만들기벽돌 변수 세팅우선 벽돌을 구현하기 위해 무엇을 먼저 해야 할까? 바로 벽돌 정보들을 저장할 변수를 선언해야 한다. 벽돌 너비라던가 높이라던가 몇 개를 몇 줄로 만들건지 라던가… 일단 아래를 봐보자. 1234567var brickRowCount = 3;var brickColumnCount = 5;var brickWidth = 75;var brickHeight = 20;var brickPadding = 10;var brickOffsetTop = 30;var brickOffsetLeft = 30; 먼저 벽돌을 5 * 3 개수로 만들 것이다. 너비는 75px, 높이는 20px, padding은 10px, 위쪽 offset은 30px, 왼쪽 offset은 30px로 선언했다. offset 값이 왜 필요할까? 이게 없으면 벽돌을 만들어서 출력하면 위쪽과 왼쪽에 딱 붙어서 벽돌 모습이 보기 흉할 것이다. 그래서 보기 좋~게 offset 만큼 거리를 떨어뜨려 화면에 그릴 것이기 때문에 offset을 주는 것이다. 자, 이제 for-loop를 이용해서 벽돌을 5 * 3 개수만큼 만들어 보자. 방법은 아래와 같다. 1234567var bricks = [];for (c = 0; c &lt; brickColumnCount; c++) &#123; bricks[c] = []; for (r = 0; r &lt; brickRowCount; r++) &#123; bricks[c][r] = &#123; x:0, y:0 &#125;; &#125;&#125; 위와 같이 벽돌을 저장할 2 2 배열을 선언 후 초기화 해준다. 그럼 총 5 3 만큼의 요소를 가진 배열이 만들어 질 것이다. 그런데 배열의 값이 { x:0, y:0 } 이라는 객체를 저장하고 있다. 이건 뭘까? 뒤에 나오겠지만 벽돌과 공이 충돌할 경우 감지할 수 있는 로직이 필요한데, 역시나 좌표를 이용해서 처리 할 것이다. 그럴려면 해당 벽돌의 X, Y 좌푤가 필요하지 않겠나? 바로 그거다. 벽돌 그리기자, 이제 벽돌을 만들 준비가 다 됬다. 그럼 이제 실제로 벽돌을 화면에 그려보도록 하자. 바로 아래와 같이 drawBricks() 함수를 선언하자! 123456789101112131415function drawBricks() &#123; for(c=0; c&lt;brickColumnCount; c++) &#123; for(r=0; r&lt;brickRowCount; r++) &#123; var brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft; var brickY = (r*(brickHeight+brickPadding))+brickOffsetTop; bricks[c][r].x = brickX; bricks[c][r].y = brickY; ctx.beginPath(); ctx.rect(brickX, brickY, brickWidth, brickHeight); ctx.fillStyle = \"#0095DD\"; ctx.fill(); ctx.closePath(); &#125; &#125;&#125; 또 loop가 두 번 돈다. 여기서 두 번째 for-loop를 보면, brickX, brickY 변수가 새로 선언되고, bricks[c][r] 에 X, Y 좌표 값으로 할당되고 있다. 이 부분이 위에서 언급한 공과의 충돌을 처리하기 위한 벽돌의 위치 정보를 저장하는 부분이다. brickX는 brickWidth + brickPadding에 컬럼의 갯수인 c 만큼 곱한 뒤 brickOffsetLeft를 통해 왼쪽에서 30px만큼 띄워서 화면에 그린다. brickY도 동일한 로직으로 위쪽과 offset 만큼 떨어뜨려 그리게 된다. 진짜로 벽돌 그리기이제, draw() 함수 안에서 drawBricks() 함수를 호출하여 벽돌을 그려보자. 그럼 아래의 데모처럼 작동할 것이다. {padding: 0; margin: 0; } canvas {background: #eee; display: block; margin: 0 auto;} var canvas = document.getElementById(“myCanvas”);var ctx = canvas.getContext(“2d”);var ballRadius = 10;var x = canvas.width/2;var y = canvas.height-30;var dx = 2;var dy = -2;var paddleHeight = 10;var paddleWidth = 75;var paddleX = (canvas.width-paddleWidth)/2;var rightPressed = false;var leftPressed = false;var brickRowCount = 3;var brickColumnCount = 5;var brickWidth = 75;var brickHeight = 20;var brickPadding = 10;var brickOffsetTop = 30;var brickOffsetLeft = 30;var bricks = [];for (c = 0; c &lt; brickColumnCount; c++) { bricks[c] = []; for (r = 0; r &lt; brickRowCount; r++) { bricks[c][r] = { x:0, y:0 }; }}document.addEventListener(“keydown”, keyDownHandler, false);document.addEventListener(“keyup”, keyUpHandler, false);function keyDownHandler(e) { if(e.keyCode == 39) { rightPressed = true; } else if(e.keyCode == 37) { leftPressed = true; }}function keyUpHandler(e) { if(e.keyCode == 39) { rightPressed = false; } else if(e.keyCode == 37) { leftPressed = false; }}function drawBricks() { for(c=0; c&lt;brickColumnCount; c++) { for(r=0; r&lt;brickRowCount; r++) { var brickX = (c(brickWidth+brickPadding))+brickOffsetLeft; var brickY = (r(brickHeight+brickPadding))+brickOffsetTop; bricks[c][r].x = brickX; bricks[c][r].y = brickY; ctx.beginPath(); ctx.rect(brickX, brickY, brickWidth, brickHeight); ctx.fillStyle = “#0095DD”; ctx.fill(); ctx.closePath(); } }}function drawBall() { ctx.beginPath(); ctx.arc(x, y, ballRadius, 0, Math.PI2); ctx.fillStyle = “#0095DD”; ctx.fill(); ctx.closePath();}function drawPaddle() { ctx.beginPath(); ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight); ctx.fillStyle = “#0095DD”; ctx.fill(); ctx.closePath();}function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawBricks(); drawBall(); drawPaddle(); if(x + dx &gt; canvas.width-ballRadius || x + dx &lt; ballRadius) { dx = -dx; } if(y + dy &lt; ballRadius) { dy = -dy; } else if(y + dy &gt; canvas.height-ballRadius) { if(x &gt; paddleX &amp;&amp; x &lt; paddleX + paddleWidth) { dy = -dy; } else { return; } } if(rightPressed &amp;&amp; paddleX &lt; canvas.width-paddleWidth) { paddleX += 7; } else if(leftPressed &amp;&amp; paddleX &gt; 0) { paddleX -= 7; } x += dx; y += dy;}setInterval(draw, 10); 엇 그런데 공이 벽돌을 그냥 통과한다… 그럼 나머지는 다음 시간에… _이 포스트는 MDN 2D Breakout game 의 튜토리얼을 참고한 내용 입니다._","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://seunghun-kim.github.io/categories/JavaScript/"},{"name":"Game","slug":"JavaScript/Game","permalink":"https://seunghun-kim.github.io/categories/JavaScript/Game/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://seunghun-kim.github.io/tags/javascript/"},{"name":"game","slug":"game","permalink":"https://seunghun-kim.github.io/tags/game/"},{"name":"html5","slug":"html5","permalink":"https://seunghun-kim.github.io/tags/html5/"}]},{"title":"javascript game (5)","slug":"js-game-05","date":"2017-04-20T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2017/04/21/js-game-05/","link":"","permalink":"https://seunghun-kim.github.io/2017/04/21/js-game-05/","excerpt":"","text":"잡담한 가지 우물을 파야 짱짱맨이 될 수 있다는데… 난 자꾸 이것 저것 해보고 싶어져서 큰일이다. 요즘은 Unity를 처음 접해서 Unity 매력에 푹 빠져 버렸다. Unity에서는 C#만 사용할 줄 알았는데 Javascript와 Boo) 라는 총 3개의 스크립트를 지원한다. 어느 스크립트를 사용하는게 성능상 유리할지는 아직 잘 모르겠지만, Javascript를 지원하니 뭔가 우리편인 거 같은 기분이(?) 들어서 더 친근감이 느껴진다. 말이야 똥이야 아무튼, 오늘은 Game Over 를 구현해보자. 지난 포스팅이 궁금하면 다음 아래 링크를 참고하기 바란다. 캔버스 생성과 그리기 공 움직이기 벽에 공 튀기기 판때기 구현과 키보드 컨트롤 Game Over지난 시간에 구현한 게임을 보고 있자면 끝없이 튕기는 공만 보이니 지루하기 그지 없다. 이제, 우리는 게임 종료에 대한 로직을 구현해보자! Game Over 구현이 게임에서 게임이 끝나려면 어떻게 하면 될까? 굉장히 간단하다. 공이 화면 아래로 떨어져버리면 끝난다. 그럼 어떻게 해야 할까? 먼저, 공이 Y축의 아래로 닿았을 경우 Game Over! 를 외치게 만들면 되겠다. 먼저, 예전에 작성한 아래와 같은 코드가 기억 나는가? 123if(y + dy &gt; canvas.height-ballRadius || y + dy &lt; ballRadius) &#123; dy = -dy;&#125; Y 축의 위 아래에 대한 공 튀기는 로직이다. 위 코드를 아래처럼 바꿔보자. 123456if (y + dy &lt; ballRadius) &#123; dy = -dy;&#125; else if (y + dy &gt; canvas.height - ballRadius) &#123; alert('Game Over!'); document.location.reload();&#125; 복잡해졌다… 하나씩 살펴보자. if (y + dy &lt; ballRadius) 이 조건절을 알아보려면 먼저 y, dy, ballRadius가 뭐였는지 기억해내야 된다. 바로 공의 Y 좌표, 공의 Y축 이동 방향 (값과 방향이 있으니 벡터라고 해도 되겠다), 공의 반지름 되시겠다. 그럼 저 조건은 뭐냐! 바로, 공의 Y 좌표가 10보다 작은 위치에 있을 경우 true 를 만족하는 조건문이다. 즉, Y축 맨 꼭대기에 닿았다는 의미이다. 이때는 벽에 맞고 공이 튕겨야 되니깐 dy의 부호를 반대로 바꿔 방향을 바꾸도록 하는 것이다. 그렇다면 그 다음! } else if (y + dy &gt; canvas.height - ballRadius) { 여기가 중요하다. canvas.height는 canvas의 높이를 나타내므로 좌표로 따졌을 때 Y축의 바닥 좌표를 나타낸다. 여기서 ballRadius인 10px만큼 뺐고, y + dy는 공의 위치를 나타낸다고 했으니, 종합해보면 아랫 바닥에 공이 부딪히면 true 인 조건문이라고 생각하면 되겟다. 그럼 이 경우가 true가 되면 공이 바닥으로 떨어져 버린거고, 우리는 신나게 Game Over!를 외쳐주면 된다. 여기에서는 alert() 함수를 통해 경고창을 띄우고, document.location.reload()를 사용해서 현재 페이지를 다시 로딩하도록 하고 있다. 자, 이제 공이 바닥에 닿으면 게임 오버 이므로 조심히 플레이 하기 바란다. 근데 이렇게만 해놓으면 공은 항상 바닥에 닿게되고, 게임이 끝나게 된다. 너무 재미 없다. 그래서 우리가 만든 판때기를 통해 공을 튕겨내도록 구현해보자. 판때기로 공 튕겨내기어떻게 할 수 있을까? 좌표.. 좌표를 생각하자! 판때기는 항상 바닥에 붙어서 양 옆으로만 움직인다. 그리고 공이 판때기에 닿았을 경우에 공이 튕겨 나가도록 방향을 바꾸면 될 것 같다. 그렇지 않은가? 우리가 알고 있는 좌표는 공의 X, Y 좌표인 x, y와 판때기의 X 좌표인 paddleX, 그리고 판때기의 너비인 paddleWidth 를 알고 있다. 그럼 준비는 다 됬다. 공의 Y 좌표가 판때기의 Y 좌표에 오고, 즉 바닥에 닿고, 공의 X 좌표가 판때기 안으로 들어왔을 경우 방향을 바꾸면 되겠다. 구현해보자! 위으 코드를 다음과 같이 바꾸면 된다. 1234567891011if(y + dy &lt; ballRadius) &#123; dy = -dy;&#125; else if(y + dy &gt; canvas.height-ballRadius) &#123; if(x &gt; paddleX &amp;&amp; x &lt; paddleX + paddleWidth) &#123; dy = -dy; &#125; else &#123; alert(\"GAME OVER\"); document.location.reload(); &#125;&#125; 우리가 중요하게 봐야 할 부분은 if(x &gt; paddleX &amp;&amp; x &lt; paddleX + paddleWidth) 이다. 공의 X 좌표가 판때기의 위치를 나타내는 (paddleX, paddleX + paddleWidth) 좌표 내에 들어올 경우, 공의 방향을 바꾸는 조건문이다. 간단하지 않는가? 그럼 이번에 고친 내용들을 수행하면 아래 데모와 같을 것이다. {padding: 0; margin: 0; } canvas {background: #eee; display: block; margin: 0 auto;} var canvas = document.getElementById(“myCanvas”);var ctx = canvas.getContext(“2d”);var ballRadius = 10;var x = canvas.width/2;var y = canvas.height-30;var dx = 2;var dy = -2;var paddleHeight = 10;var paddleWidth = 75;var paddleX = (canvas.width-paddleWidth)/2;var rightPressed = false;var leftPressed = false;document.addEventListener(“keydown”, keyDownHandler, false);document.addEventListener(“keyup”, keyUpHandler, false);function keyDownHandler(e) { if(e.keyCode == 39) { rightPressed = true; } else if(e.keyCode == 37) { leftPressed = true; }}function keyUpHandler(e) { if(e.keyCode == 39) { rightPressed = false; } else if(e.keyCode == 37) { leftPressed = false; }}function drawBall() { ctx.beginPath(); ctx.arc(x, y, ballRadius, 0, Math.PI2); ctx.fillStyle = “#0095DD”; ctx.fill(); ctx.closePath();}function drawPaddle() { ctx.beginPath(); ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight); ctx.fillStyle = “#0095DD”; ctx.fill(); ctx.closePath();}function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawBall(); drawPaddle(); if(x + dx &gt; canvas.width-ballRadius || x + dx &lt; ballRadius) { dx = -dx; } if(y + dy &lt; ballRadius) { dy = -dy; } else if(y + dy &gt; canvas.height-ballRadius) { if(x &gt; paddleX &amp;&amp; x &lt; paddleX + paddleWidth) { dy = -dy; } else { return; } } if(rightPressed &amp;&amp; paddleX &lt; canvas.width-paddleWidth) { paddleX += 7; } else if(leftPressed &amp;&amp; paddleX &gt; 0) { paddleX -= 7; } x += dx; y += dy;}setInterval(draw, 10); 아, 게임 오버가 되면 계속 alert() 때문에 굉장히 귀찮아서 주석처리 해놨다. 그럼 나머지는 다음 시간에… _이 포스트는 MDN 2D Breakout game 의 튜토리얼을 참고한 내용 입니다._","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://seunghun-kim.github.io/categories/JavaScript/"},{"name":"Game","slug":"JavaScript/Game","permalink":"https://seunghun-kim.github.io/categories/JavaScript/Game/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://seunghun-kim.github.io/tags/javascript/"},{"name":"game","slug":"game","permalink":"https://seunghun-kim.github.io/tags/game/"},{"name":"html5","slug":"html5","permalink":"https://seunghun-kim.github.io/tags/html5/"}]},{"title":"javascript game (4)","slug":"js-game-04","date":"2017-04-19T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2017/04/20/js-game-04/","link":"","permalink":"https://seunghun-kim.github.io/2017/04/20/js-game-04/","excerpt":"","text":"잡담오늘은 공을 튕길 수 있는 판때기를 만드는 방법과 키보드를 통해 그 판때기를 이동하도록 구현을 해볼 것이다. 이제 좀 게임같이 보일 것이다. 지난 포스팅이 궁금하면 다음 아래 링크를 참고하기 바란다. 캔버스 생성과 그리기 공 움직이기 벽에 공 튀기기 판때기 구현과 키보드 컨트롤그럼 시작 해 볼까? 판때기 구현판때기 구현을 위해 몇 가지 변수를 선언해보자. 필요한 변수는 판때기 높이와 너비, 그리고 판때기의 X 좌표를 저장할 변수이다. 바로 이렇게! 123var paddleHeight = 10;var paddleWidth = 75;var paddleX = (canvas.width - paddleWidth) / 2; 판때기 높이는 10px, 너비는 75px, X 좌표는 canvas의 너비를 기준으로 판때기 만큼 뺀 다음 2로 나눠서 중앙에 위치하도록 설정했다. 왜 canvas.width / 2 로 안하고 (canvas.width - paddleWidth) / 2 로 하냐고? 전자는 판때기가 중앙에 위치하지 않는다. 못믿겠으면 아래 판때기 그리는 함수를 구현한 후 실행해보면 된다. 판때기 그리는 함수를 만들어 보자. 1234567function drawPaddle() &#123; ctx.beginPath(); ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight); ctx.fillStyle = '#0095DD'; ctx.fill(); ctx.closePath();&#125; 위에 선언했던 변수들을 바탕으로 직각사각형 하나를 그렸다. Y축의 시작 좌표가 왜 canvas.height - paddleHeight 인지 궁금한 사람이 있을 것이다. canvas.height는 웹에 표시되는 canvas의 가장 아래 좌표를 가리킨다. 우리는 canvas를 선언할 때 다음과 같이 했었다. 기억 안나지? 1&lt;canvas id=\"myCanvas\" width=\"480\" height=\"320\"&gt;&lt;/canvas&gt; 즉, 320px로 지정했으니 canvas.height의 값은 320이 나올 것이다. 그런데! 만약 우리가 판때기의 위치 중 Y좌표를 canvas.height 만 했다면? 판때기가 canvas 아래로 벗어나서 보이지 않을 것이다. 따라서 Y축 위치를 위로 10px만큼 옮겨주기 위해 canvas.height - paddleHeight 가 된 것이다. 그리고 나서 drawPaddle() 함수를 draw()에 넣어주자. 그럼 화면에 판때기 하나가 그려졌을 것이다. 하지만 움직이지 않는다… 사용자가 키보드를 사용해서 판때기를 움직이게 하기쉽다. 이벤트를 구현해주면 된다. 이벤트는 뭔가요? 먼저 우리는 오른쪽, 왼쪽에 대한 값을 저장할 변수가 필요하다. 선언하자. 12var rightPressed = false;var leftPressed = false; 두 변수의 초기값이 false인 이유는 처음에는 당연히 키보드가 안눌려 있기 때문이다. 내가 먼저 누를꺼니깐 그럼 저 변수를 어떻게 사용할 것인가? 바로 순수 자바스크립트를 이용해서 왼쪽 방향키와 오른쪽 방향키에 대해 이벤트를 등록해서 사용할 것이다. 바로 이렇게! 123456789101112131415document.addEventListener('keydown', function(e) &#123; if (e.keyCode === 39) &#123; rightPressed = true; &#125; else if (e.keyCode === 37) &#123; leftPressed = true; &#125;&#125;, false);document.addEventListener('keyup', function(e) &#123; if (e.keyCode === 39) &#123; rightPressed = false; &#125; else if (e.keyCode === 37) &#123; leftPressed = false; &#125;&#125;, false); MDN의 예제에는 콜백 함수가 따로 선언되어 있지만 나는 귀찮아서 익명 함수로 생성해서 사용했다. 그리고 파라미터로 넘어간 e는 이벤트 객체이다. addEventListener()는 여기 에서 참고해서 보면 된다. 절대 귀찮아서 그런거 아니다 자, 이제 실행해 보자. 잘 움직이는가? ㅋㅋㅋㅋ 움직이지 않을 것이다. 왜? 이벤트만 추가했지 실질적으로 판때기를 움직이는 로직은 아직 구현하지 않았기 때문이다. 마지막으로 아래 코드를 draw() 함수에 끝부분에 적어준다. 123456if(rightPressed &amp;&amp; paddleX &lt; canvas.width-paddleWidth) &#123; paddleX += 7;&#125;else if(leftPressed &amp;&amp; paddleX &gt; 0) &#123; paddleX -= 7;&#125; 간단하다. 오른쪽 방향키가 눌리면 rightPressed가 true가 될 꺼고, 판때기 X 좌표가 canvas.width - paddleWidth 보다 작다면 paddleX 에 7px 만큼 더해줘서 오른쪽으로 움직이는 효과를 주었다. 그럼 왼쪽은 반대로 생각하면 되겠지? 자, 이제 코드를 실행해보자. 이번엔 잘 움직일 것이다. 바로 이렇게 {padding: 0; margin: 0; } canvas {background: #eee; display: block; margin: 0 auto;} var canvas = document.getElementById(“myCanvas”);var ctx = canvas.getContext(“2d”);var ballRadius = 10;var x = canvas.width/2;var y = canvas.height-30;var dx = 2;var dy = -2;var paddleHeight = 10;var paddleWidth = 75;var paddleX = (canvas.width-paddleWidth)/2;var rightPressed = false;var leftPressed = false;document.addEventListener(“keydown”, keyDownHandler, false);document.addEventListener(“keyup”, keyUpHandler, false);function keyDownHandler(e) { if(e.keyCode == 39) { rightPressed = true; } else if(e.keyCode == 37) { leftPressed = true; }}function keyUpHandler(e) { if(e.keyCode == 39) { rightPressed = false; } else if(e.keyCode == 37) { leftPressed = false; }}function drawBall() { ctx.beginPath(); ctx.arc(x, y, ballRadius, 0, Math.PI2); ctx.fillStyle = “#0095DD”; ctx.fill(); ctx.closePath();}function drawPaddle() { ctx.beginPath(); ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight); ctx.fillStyle = “#0095DD”; ctx.fill(); ctx.closePath();}function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawBall(); drawPaddle(); if(x + dx &gt; canvas.width-ballRadius || x + dx &lt; ballRadius) { dx = -dx; } if(y + dy &gt; canvas.height-ballRadius || y + dy &lt; ballRadius) { dy = -dy; } if(rightPressed &amp;&amp; paddleX &lt; canvas.width-paddleWidth) { paddleX += 7; } else if(leftPressed &amp;&amp; paddleX &gt; 0) { paddleX -= 7; } x += dx; y += dy;}setInterval(draw, 10); 그런데 판때기가 공을 튕기지 않는 기분이다… 나머지는 다음 시간에! _이 포스트는 MDN 2D Breakout game 의 튜토리얼을 참고한 내용 입니다._","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://seunghun-kim.github.io/categories/JavaScript/"},{"name":"Game","slug":"JavaScript/Game","permalink":"https://seunghun-kim.github.io/categories/JavaScript/Game/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://seunghun-kim.github.io/tags/javascript/"},{"name":"game","slug":"game","permalink":"https://seunghun-kim.github.io/tags/game/"},{"name":"html5","slug":"html5","permalink":"https://seunghun-kim.github.io/tags/html5/"}]},{"title":"javascript game (3)","slug":"js-game-03","date":"2017-04-18T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2017/04/19/js-game-03/","link":"","permalink":"https://seunghun-kim.github.io/2017/04/19/js-game-03/","excerpt":"","text":"잡담이번에는 지난 시간에 만들었던 공이 움직이는 기능에다가 공이 벽에 닿았을 경우 Bounce! Bounce! 할 수 있도록 수정해 보겠다. 지난 포스팅이 궁금하면 다음 아래 링크를 참고하기 바란다. 캔버스 생성과 그리기 공 움직이기 벽에 공 튀기기어떻게 튕기게 할 수 있을까? 세게 던지면 튕겨 나온다 우리는 좌표에 관심을 가져야 한다. 간단한 충돌 감지일단 공이 벽에 부딪혔다고 가정하자. 그럼 어떠한 일이 일어나야 할까? 공의 방향이 바뀌면 된다. 간단하네 앞에서 우리는 ctx.arc()를 통해 공을 그릴 때 공의 반지름을 10으로 하드코딩 했었는데 이를 변수로 바꾸도록 하자. 왜냐고? 안그러면 벽에 부딪힐 때 공이 벽 안으로 들어가게 보이는걸 방지하기 위해서 이다. 1234var ballRadius = 10;...ctx.arc(x, y, ballRadius, 0, Math.PI*2);... 공 튕겨내기천장과 바닥에 닿았을 때 방향을 바꿔서 공이 진행하도록 만들면 튕겨내는 기분이 들 것 같다. 기분 탓인가? 그럼 어떻게 구현을 해야 할까? 먼저 천장을 생각해 보자. 말이 천장이지, 2D 화면에서 천장은 Y축을 가리킨다. canvas에서 Y축의 좌표가 0이면 천장을 가리키는 셈이다. 그럼 답이 나왔다. 공의 좌표인 y가 0 보다 작으면 천장에 부딪힌 것으로 판단할 수 있겠다. 바로 이렇게. 123if (y &lt; 0) &#123; dy = -dy;&#125; y 값이 0보다 작아지면 천장에 부딪힌 것이고, dy의 부호를 바꿔서 Y축으로의 이동 방향을 바꾸면 튕겨 나오는 효과를 볼 수 있다. MDN의 예제에서는 아래와 같이 나와 있는데, 사실 같은 의미이다. y + dy &lt; 0 이 되려면, dy의 부호가 음수일 것이고, 공의 방향은 위로 향하고 있다는 의미가 될 것이다. 0보다 작아졌다면 천장에 부딪힌 시점이고, dy 의 부호를 바꿔 반대 방향으로 이동하게 만드는 것이다. 완전히 똑같다. 123if(y + dy &lt; 0) &#123; dy = -dy;&#125; 그럼 바닥에 부딪혔을 때는 어떻게 처리하면 될까? 천장과 마찬가지로 바닥의 Y좌표에 부딪혔을 경우 dy의 부호를 변경해 주면 된다. 바닥의 Y 좌표는?? 그렇다. canvas.height 가 바로 바닥의 Y좌표이다. 이렇게 해주거나 123if (y &gt; canvas.height) &#123; dy = -dy;&#125; 이렇게 해주면 된다. 123if (y + dy &gt; canvas.height) &#123; dy = -dy;&#125; 이제 위의 소스코드를 하나로 합쳐보자. 123if (y + dy &gt; canvas.height || y + dy &lt; 0) &#123; dy = -dy;&#125; 참 쉽다. 자, 그럼 이제 왼쪽 오른쪽에 부딪혔을 경우에는 어떻게 구현하면 될까? 천장, 바닥과 똑같다. 바로 X축의 좌표를 이용해서 하면 된다. 두 번 설명하면 지루하니깐 바로 소스코드를 보자. 123if (x + dx &gt; canvas.width || x + dx &lt; 0 ) &#123; dx = -dx;&#125; 참 쉽죠? 이제 위에서 만든 if 문 2개를 draw() 함수 안으로 옮겨보자. 1234567891011121314function draw() &#123; ctx.clearRect(0, 0, canvas.width, canvas.height); drawBall(); if(x + dx &gt; canvas.width || x + dx &lt; 0) &#123; dx = -dx; &#125; if(y + dy &gt; canvas.height || y + dy &lt; 0) &#123; dy = -dy; &#125; x += dx; y += dy;&#125; 그럼, 이제 아래와 같이 통통 튕기는 공을 볼 수 있을 것이다. {padding: 0; margin: 0; } canvas {background: #eee; display: block; margin: 0 auto;} const canvas = document.getElementById(‘myCanvas’); const ctx = canvas.getContext(‘2d’); let x = canvas.width / 2; let y = canvas.height - 30; let dx = 2; let dy = -2; function drawBall() { ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI2); ctx.fillStyle = “#0095DD”; ctx.fill(); ctx.closePath(); } function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawBall(); if(x + dx &gt; canvas.width || x + dx &lt; 0) { dx = -dx; } if(y + dy &gt; canvas.height || y + dy &lt; 0) { dy = -dy; } x += dx; y += dy; } setInterval(draw, 10); 자 어떤가! 공이 신나게 통통 튕기지 않는가! 그런데 자세히 보면 공이 벽에 파묻혔다가 튕겨 나오는 기분이다. 절대 기분탓이 아니다. 여기에서 이제 위에서 언급했던 ballRadius 가 등장할 시점이다. 천장, 바닥, 왼쪽, 오른쪽에 부딪힐 때 ballRadius 만큼의 차이를 두면 좀 더 자연스럽게 튕기는 모습을 볼 수 있다. if 문에 다음과 같이 수정을 해보자. 123456if(x + dx &gt; canvas.width - ballRadius || x + dx &lt; ballRadius) &#123; dx = -dx;&#125;if(y + dy &gt; canvas.height - ballRadius || y + dy &lt; ballRadius) &#123; dy = -dy;&#125; 다시 실행을 시켜보면 아래와 같이 좀 더 자연스럽게, 공이 벽에 닿자 마자 튕기는 모습을 볼 수 있다. {padding: 0; margin: 0; } canvas {background: #eee; display: block; margin: 0 auto;} const canvas1 = document.getElementById(‘myCanvas1’); const ctx1 = canvas1.getContext(‘2d’); let x1 = canvas1.width / 2; let y1 = canvas1.height - 30; let dx1 = 2; let dy1 = -2; const ballRadius1 = 10; function drawBall1() { ctx1.beginPath(); ctx1.arc(x1, y1, ballRadius1, 0, Math.PI2); ctx1.fillStyle = “#0095DD”; ctx1.fill(); ctx1.closePath(); } function draw1() { ctx1.clearRect(0, 0, canvas1.width, canvas1.height); drawBall1(); if(x1 + dx1 &gt; canvas1.width - ballRadius1 || x1 + dx1 &lt; ballRadius1) { dx1 = -dx1; } if(y1 + dy1 &gt; canvas1.height - ballRadius1 || y1 + dy1 &lt; ballRadius1) { dy1 = -dy1; } x1 += dx1; y1 += dy1; } setInterval(draw1, 10); 나머지는 다음 시간에… _이 포스트는 MDN 2D Breakout game 의 튜토리얼을 참고한 내용 입니다._","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://seunghun-kim.github.io/categories/JavaScript/"},{"name":"Game","slug":"JavaScript/Game","permalink":"https://seunghun-kim.github.io/categories/JavaScript/Game/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://seunghun-kim.github.io/tags/javascript/"},{"name":"game","slug":"game","permalink":"https://seunghun-kim.github.io/tags/game/"},{"name":"html5","slug":"html5","permalink":"https://seunghun-kim.github.io/tags/html5/"}]},{"title":"javascript game 2 (1)","slug":"js-game2-01","date":"2017-04-18T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2017/04/19/js-game2-01/","link":"","permalink":"https://seunghun-kim.github.io/2017/04/19/js-game2-01/","excerpt":"","text":"잡담앞에 포스트에서 만들었던 공 튀기기를 베껴서 갤러그를 만들어 봤다. 갤러그 보다는 갤러가가 맞다고 한다…?! 아직 손 볼 부분은 많은데 그래도 일단 포스팅을 하고 보자. 데모 Gamedev Canvas Workshop * { padding: 0; margin: 0; } canvas { background: #eee; display: block; margin: 0 auto; } &lt;/style&gt; var canvas = document.getElementById(‘myCanvas’); var ctx = canvas.getContext(‘2d’); var theEnd = false; var retry = true; var score = 0; var lives = 3; var level = 1; var shipColor = ‘cyan’; var shipWidth = 30; var shipHeight = 10; var shipX = (canvas.width - shipWidth) / 2 var shipY = canvas.height - shipHeight; var gunWidth = 6; var gunHeight = 5; var leftGunX = shipX; var rightGunX = shipX + shipWidth - gunWidth; var gunsY = shipY - gunHeight; var bulletColor = ‘red’; var bulletWidth = 3; var bulletHeight = 5; var bulletY = gunsY - bulletHeight; var bulletCount = 10; var firstFire = true; var bulletStatus = 1; var leftBulletX = leftGunX + ((gunWidth - bulletWidth) / 2); var rightBulletX = rightGunX + ((gunWidth - bulletWidth) / 2); var enemiesColor = ‘red’; var enemiesColumnCount = 7; var enemiesRowCount = 2; var enemyWidth = 30; var enemyHeight = 10; var enemyPadding = 36; var enemyOffsetTop = 30; var enemyOffsetLeft = 30; var enemiesMoving = 0; var enemiesMovingLimit = 15; var enemiesAttackWidth = 5; var enemiesAttackHeight = 10; var enemiesAttackX = -1; var enemiesAttackY = -1; var ed = 0.3; var eaSpeed = 9; var enemies = []; function initEnemies() { for (c = 0; c &lt; enemiesColumnCount; c++) { enemies[c] = []; for (r = 0; r &lt; enemiesRowCount; r++) { enemies[c][r] = { x: 0, y: 0, status: 1 }; } } } initEnemies(); var rightPressed = false; var leftPressed = false; document.addEventListener(‘keydown’, function(e) { if (e.keyCode === 39) { rightPressed = true; } else if (e.keyCode === 37) { leftPressed = true; } }, false); document.addEventListener(‘keyup’, function(e) { if (e.keyCode === 39) { rightPressed = false; } else if (e.keyCode === 37) { leftPressed = false; } }, false); document.addEventListener(‘mousemove’, function(e) { var relativeX = e.clientX - canvas.offsetLeft; if (relativeX &gt; 0 &amp;&amp; relativeX &lt; canvas.width) { shipX = relativeX - shipWidth / 2; leftGunX = shipX; rightGunX = shipX + shipWidth - gunWidth; } }, false); function drawScore() { ctx.font = ‘16px arial’; ctx.fillStyle = ‘#0095DD’; ctx.fillText(‘Score: ‘ + score, 8, 20); } function drawLives() { ctx.font = ‘16px arial’; ctx.fillStyle = ‘#0095DD’; ctx.fillText(‘Lives: ‘ + lives, canvas.width / 2 - 30, 20); // fillText(text, x, y); } function drawLevel() { ctx.font = ‘16px arial’; ctx.fillStyle = ‘#0095DD’; ctx.fillText(‘Level: ‘ + level, canvas.width - 65, 20); // fillText(text, x, y); } function drawEnemies() { for (c = 0; c &lt; enemiesColumnCount; c++) { for (r = 0; r &lt; enemiesRowCount; r++) { if (enemies[c][r].status === 1) { var enemyX = (c (enemyWidth + enemyPadding)) + enemyOffsetLeft + enemiesMoving; var enemyY = (r (enemyHeight + enemyPadding)) + enemyOffsetTop; enemies[c][r].x = enemyX; enemies[c][r].y = enemyY; var attack = (Math.random() 30) &lt; 1; if (attack &amp;&amp; enemiesAttackY === -1) { enemiesAttackX = enemyX; enemiesAttackY = enemyY; } ctx.beginPath(); ctx.rect(enemyX, enemyY, enemyWidth, enemyHeight); ctx.fillStyle = enemiesColor; ctx.fill(); ctx.closePath(); } } } if (enemiesMoving &gt; enemiesMovingLimit) { ed = -ed; } else if (enemiesMoving &lt; enemiesMovingLimit (-1)) { ed = -ed; } enemiesMoving += ed; return enemiesAttackX; } function collisionDetection(blx, brx) { for (c = 0; c &lt; enemiesColumnCount; c++) { for (r = 0; r &lt; enemiesRowCount; r++) { var e = enemies[c][r]; if (e.status === 1) { if ((blx &gt; e.x &amp;&amp; blx &lt; e.x + enemyWidth &amp;&amp; bulletY &gt; e.y &amp;&amp; bulletY &lt; e.y + enemyHeight) || (brx &gt; e.x &amp;&amp; brx &lt; e.x + enemyWidth &amp;&amp; bulletY &gt; e.y &amp;&amp; bulletY &lt; e.y + enemyHeight)) { score++; initBullet(); e.status = 0; if (score === enemiesColumnCount enemiesRowCount level) { alert(‘Level UP!!’); // level up level += 1; enemyWidth -= 2; shipWidth += 5; shipHeight += 2; eaSpeed += 0.5; initEnemies(); if (!retry &amp;&amp; enemyWidth &lt;= 0) { alert(‘Congraturation!\\n You Finished All stages!’); theEnd = true; } else { draw(); } } } } } } } function attackedDetection(attackX) { if (enemiesAttackY &gt; canvas.height) { enemiesAttackX = -1; enemiesAttackY = -1; } if (attackX &gt; shipX &amp;&amp; attackX &lt; shipX + shipWidth &amp;&amp; enemiesAttackY &gt; shipY &amp;&amp; enemiesAttackY &lt; shipY + shipHeight) { lives–; } } function drawBullet(leftX, rightX) { ctx.beginPath(); ctx.rect(leftX, bulletY, bulletWidth, bulletHeight); ctx.rect(rightX, bulletY, bulletWidth, bulletHeight); ctx.fillStyle = bulletColor; ctx.fill(); ctx.closePath(); } function initBullet() { bulletY = gunsY - bulletHeight; leftBulletX = leftGunX + ((gunWidth - bulletWidth) / 2); rightBulletX = rightGunX + ((gunWidth - bulletWidth) / 2); } function drawShip() { ctx.beginPath(); // body of ship ctx.rect(shipX, shipY, shipWidth, shipHeight); // left gun of ship ctx.rect(leftGunX, gunsY, gunWidth, gunHeight); // right gun of ship ctx.rect(rightGunX, gunsY, gunWidth, gunHeight); ctx.fillStyle = shipColor; ctx.fill(); ctx.closePath(); } function drawAttack(attackX) { ctx.beginPath(); ctx.rect(attackX, enemiesAttackY, enemiesAttackWidth, enemiesAttackHeight); ctx.fillStyle = enemiesColor; ctx.fill(); ctx.closePath(); } function draw() { if (theEnd) { return; } ctx.clearRect(0, 0, canvas.width, canvas.height); drawShip(); drawBullet(leftBulletX, rightBulletX); var enemiesAttackX = drawEnemies(); if (enemiesAttackX !== -1 &amp;&amp; enemiesAttackY !== -1) { drawAttack(enemiesAttackX); enemiesAttackY += eaSpeed; } attackedDetection(enemiesAttackX); collisionDetection(leftBulletX, rightBulletX); drawScore(); drawLives(); drawLevel(); bulletY -= 2; if (lives === 0) { retry = confirm(‘Game Over!\\nDo you want to retry?’); if (retry) { document.location.reload(); } else { return; } } if (rightPressed &amp;&amp; shipX + shipWidth &lt; canvas.width) { shipX = leftGunX += 7; rightGunX += 7; } else if (leftPressed &amp;&amp; shipX &gt; 0) { shipX = leftGunX -= 7; rightGunX -= 7; } if (bulletY &lt; 0) { initBullet(); } requestAnimationFrame(draw); } draw(); 비행기의 총알이 레벨이 올라갈수록 빨라지는데… 의도된건 아니다. ㅋㅋㅋ 누가 네모만 있다고 뭐라 했는데 절대 귀찮아서 그런건 아니다. 개취이다. 아무튼…","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://seunghun-kim.github.io/categories/JavaScript/"},{"name":"Game","slug":"JavaScript/Game","permalink":"https://seunghun-kim.github.io/categories/JavaScript/Game/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://seunghun-kim.github.io/tags/javascript/"},{"name":"game","slug":"game","permalink":"https://seunghun-kim.github.io/tags/game/"},{"name":"html5","slug":"html5","permalink":"https://seunghun-kim.github.io/tags/html5/"}]},{"title":"javascript game (2)","slug":"js-game-02","date":"2017-04-17T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2017/04/18/js-game-02/","link":"","permalink":"https://seunghun-kim.github.io/2017/04/18/js-game-02/","excerpt":"","text":"잡담이 포스팅은 한번 따라만 해보면 금방 잊어버리니간 되새김질을 하기 위해 작성하는 것이다. 잡담 끝! 본론으로 들어가보자. Move the Ball그리는 함수 정의하기이번 튜토리얼부터 영어다… 후후후.. 내맘데로 번역이니 충분히 이상 할 수 있다. 먼저 지속적으로 반복하면서 canvas에 이미지를 그리는 함수를 정의하자. for-loop 보다 setInterval()을 사용하고, 마지막에는 requestAnimationFrame()으로 변경 할 것이다. 12345678function draw() &#123; ctx.beginPath(); ctx.arc(50, 50, 10, 0, Math.PI*2); ctx.fillStyle = '#0095DD'; ctx.fill(); ctx.closePath();&#125;setInterval(draw, 10); 자, 이제 10ms 마다 draw() 함수가 실행되면서 좌표 (50, 50)에 반지름 10px의 원을 그리게 되었다. 실행해보자! 굉장히 재미없는 동그라미만 찍혀있다 움직이게 만들기자, 움직이게 하기 위해서 무엇을 해야 할까? 이 부분을 살펴보자. 1ctx.arc(50, 50, 10, 0, Math.PI*2); 좌표 (50, 50) 이 하드 코딩 되어 있다. 이 부분을 동적으로 바꿔주면 왠지 움직일 것 같지 않은가? 해보자. 변수를 추가해보자. 총 4개의 변수가 추가될껀데, 두 개는 초기 공의 좌표를 나타낼 x, y 와 공이 이동할 좌표인 dx, dy 이다. 1234var x = canvas.width / 2;var y = canvas.height - 30;var dx = 2;var dy = -2; x는 canvas의 정 중앙으로, y는 canvas의 맨 아래에서 30px 만큼 띄운 상태를 공의 초기 값으로 설정하였다. dx는 오른쪽으로 2px 움직이고, dy는 위로 2xp 움직이도록 설정하였다. 그럼 draw() 함수를 수정해서 공이 움직이도록 만들어 보자. 123456789function draw() &#123; ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI*2); ctx.fillStyle = \"#0095DD\"; ctx.fill(); ctx.closePath(); x += dx; y += dy;&#125; draw() 함수가 실행할 때 마다 x와 y의 값이 변하면서 공이 움직이게 되었다! 유레카 근데 이상한게 하나 있다. 공이 움직이면서 흔적을 남긴다. 공이라기 보다는 선이 그려지는 기분이다. 이 문제를 어떻게 해결할까? 바로 clearRect()함수를 써서 canvas의 그림들을 지우면 된다. 소스코드를 아래와 같이 수정해보자. 1234567891011121314function drawBall() &#123; ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI*2); ctx.fillStyle = \"#0095DD\"; ctx.fill(); ctx.closePath();&#125;function draw() &#123; ctx.clearRect(0, 0, canvas.width, canvas.height); drawBall(); x += dx; y += dy;&#125; 보기 좋게 drawBall() 함수를 생성해서 공을 그리는 부분을 draw() 함수와 분리하였다. clearRect() 함수의 파라미터는 처음 2개는 clear를 수행할 시작 좌표, 뒤의 2개는 끝 좌표를 나타낸다. 즉, canvas의 모든 그림들을 지우겠다는 의미이다. 그 후에 drawBall()을 수행하니 우리가 원하는 공이 움직이는 기능이 구현되었다. 유레카 {padding: 0; margin: 0; } canvas {background: #eee; display: block; margin: 0 auto;} var canvas = document.getElementById(‘myCanvas’); var ctx = canvas.getContext(‘2d’); var x = canvas.width / 2; var y = canvas.height - 30; var dx = 2; var dy = -2; function drawBall() { ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI2); ctx.fillStyle = “#0095DD”; ctx.fill(); ctx.closePath(); } function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawBall(); x += dx; y += dy; } setInterval(draw, 10); _이 포스트는 MDN 2D Breakout game 의 튜토리얼을 참고한 내용 입니다._","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://seunghun-kim.github.io/categories/JavaScript/"},{"name":"Game","slug":"JavaScript/Game","permalink":"https://seunghun-kim.github.io/categories/JavaScript/Game/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://seunghun-kim.github.io/tags/javascript/"},{"name":"game","slug":"game","permalink":"https://seunghun-kim.github.io/tags/game/"},{"name":"html5","slug":"html5","permalink":"https://seunghun-kim.github.io/tags/html5/"}]},{"title":"javascript game (1)","slug":"js-game-01","date":"2017-04-16T15:00:00.000Z","updated":"2017-11-24T16:07:14.000Z","comments":true,"path":"2017/04/17/js-game-01/","link":"","permalink":"https://seunghun-kim.github.io/2017/04/17/js-game-01/","excerpt":"","text":"잡담javascript와 친해지기 위해 뭐가 좋을까 고민을 하다가 예전에 codeschool.com에서 웹으로 만든 게임을 본 것 같은 기억이 있어서 한번 따라해볼까… 하고 들어가봤는데 못찾았다 ㅋㅋ 그래서 Google에서 검색해보니 MDN(Mozilla Developer Network)에서 벽돌 깨기 튜토리얼을 찾았다. 순서는 다음과 같다. (링크는 원문을, 옆에 해쉬 태크는 본 블로그로!) 캔버스 생성과 그리기 #1 공 움직이기 #2 벽으로 부터 튕겨나오기 #3 판때기 구현과 키보드 컨트롤 #4 Game Over #5 벽돌 만들기 #6 충돌 감지 #7 점수 추적과 승리 #8 마우스 컨트롤 #9 마무리 #10 데모를 보자. [여기] 를 클릭하면 데모를 확인할 수 있다. 그럼 따라해보자! first캔버스 생성과 그리기! 먼저, html 파일을 만든다. 여기서 중요한건, canvas 태그를 만들고, 그 안에서 벽돌을 부시고 지지고 할꺼다. 그럼 만들어보자. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Gamedev Canvas Workshop&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; canvas &#123; background: #eee; display: block; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id=\"myCanvas\" width=\"480\" height=\"320\"&gt;&lt;/canvas&gt;&lt;script&gt; // JavaScript 코드가 여기에 들어갈 것입니다.&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; html은 간단하니 따로 설명은 생략하겠다. javascript에서 canvas 엘리먼트의 아이디를 가져와서 지지고 볶고 해야한다. 이번 튜토리얼은 pure javascript 이므로 오직 javascript 문법만을 통해 구현을 할 것이다. 아래 코드는 canvas 엘리먼트를 가져오고, 그 canvas를 2d로 설정 후, 사각형을 그리는 예제이다. 12345678var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.beginPath();ctx.rect(20, 40, 50, 50);ctx.fillStyle = \"#FF0000\";ctx.fill();ctx.closePath(); 위 코드를 보면, ctx.beginPath()는 그리기를 시작한다고 알려주는 메소드이며, ctx.closePath()는 그리기가 끝났다고 알리는 메소드이다. 즉, 그리고 지지고 볶는 로직은 두 메소드 안에 작성하면 된다. 여기에서는 ctx.rect() 메소드를 통해 사각형을 그리는데 x 좌표의 시작 위치가 20px, y 좌표의 시작 위치가 40px이며, width와 height를 모두 50으로 정 사각형을 그리는 것이다. ctx.fillStyle을 통해 색상을 지정할 수 있으며, FF0000는 빨강을 의미한다. 그리고 ctx.fill()을 수행하면 ctx.fillStyle에서 지정된 색상으로 채워진다. 신기하지? 난 그랬는데 다음은 동그라미 원을 그리는 예제이다. 12345ctx.beginPath();ctx.arc(240, 160, 20, 0, Math.PI*2, false);ctx.fillStyle = \"green\";ctx.fill();ctx.closePath(); 여기서 사각형 부분과 다른 점은 ctx.arc() 메소드와 ctx.fillStyle의 값이 문자열로 되어 있다는 점이다. ctx.arc()의 첫 번째 파라미터는 원 중심의 x좌표를 가리키며 여기에서는 240px이다. 그럼 다음은 바로 느낌이 오지 않는가? y좌표이며 260px을 나타낸다. 그 다음은?? 길이가 20px인 반지름을 나타낸다. 그럼 그 다음은??? 원의 시작과 끝의 각도를 각각 나타내며 라디안 값으로 나타낸다. 마지막 파라미터는 옵션이며, 그리는 방향을 나타내는데 false는 시계 방향을, true는 반시계 방향을 나타낸다. 복잡하네 ctx.fillStyle은 맨 처음처럼 16진수도 되고, 색상 키워드도 되고, rgba() 함수도 된다고 한다. 그리고 마지막! 원의 외곽선에 색상을 부여해보자. 12345ctx.beginPath();ctx.rect(160, 10, 100, 40);ctx.strokeStyle = \"rgba(0, 0, 255, 0.5)\";ctx.stroke();ctx.closePath(); rgba() 함수의 파라미터는 각각 red, green, blue, alpha 값을 나타내는데, 여기서는 불투명한 파란색을 나타내는 것이다. 그럼 나머지는 다음 시간에… _이 포스트는 MDN 2D Breakout game 의 튜토리얼을 참고한 내용 입니다._","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://seunghun-kim.github.io/categories/JavaScript/"},{"name":"Game","slug":"JavaScript/Game","permalink":"https://seunghun-kim.github.io/categories/JavaScript/Game/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://seunghun-kim.github.io/tags/javascript/"},{"name":"game","slug":"game","permalink":"https://seunghun-kim.github.io/tags/game/"},{"name":"html5","slug":"html5","permalink":"https://seunghun-kim.github.io/tags/html5/"}]},{"title":"Start JavaScript!","slug":"js-start","date":"2017-04-11T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2017/04/12/js-start/","link":"","permalink":"https://seunghun-kim.github.io/2017/04/12/js-start/","excerpt":"","text":"잡담책 산지가 언젠데… 아직도… 보고있다니… 부끄럽다. 사고싶은 책은 많은데 이리도 진도가 안나가서야 언제 또 사나… 걱정이다. 아무튼, 예전에 웹개발 잠깐 맛보기로 배울때 html, JavaScript, css 이 세 가지를 기본으로 배웠다. 이때 이해했던 JavaScript는 그저 이벤트 처리용으로 사용되는 간단한 스크립트 언어였다. 문법도 Java랑 비슷하고, 사용법도 굉장히 간단했다. 그게 다인줄 알았다. 요즘 다시 JavaScript를 보면서 엄청난 오해를 했었다는 사실을 알게 되었다. JavaScript는 굉장하다. 왜그런지는 직접 해보면 안다. What is JavaScript?나도 아직 잘 모른다. 하지만 함수형 프로그래밍이 가능하고, 객체지향 프로그래밍이 가능하다는 것이다. 그렇다고 해서 완전한 함수형 언어는 아니다. 그리고, 가장 중요한 점은 JavaScript는 프로토타입 기반의 언어라는 점이다. 이 프로토타입을 이용해서 객체의 상속과 같은 기능을 구현할 수 있다. 간단하게 맛만 보자면 1234567var object = (function() &#123; function F() &#123;&#125;; return function(o) &#123; F.prototype = o; return new F(); &#125;;&#125;)(); 위 소스코드는 무엇을 하는 것일까? 결론부터 말하자면 o 라는 객체를 상속받는 새로운 객체를 생성하는 코드이다. 정말? 지금은 ES6 (ECMAScript 6)부터 class 문법을 제공하므로 위와 같이 상속받지 않고, OOP-style의 extends 키워드를 통해 간단하게 상속을 구현할 수 있다. 하지만 자바스크립트를 제대로 공부하려면 위와같이 prototype을 이용한 상속도 알아야 할 것이다. 아무튼, 앞으로도 계속 공부해야겠다. ps. 책을 새로 또 샀다… 자바스크립트 완벽 가이드. 앞으로의 자바스크립트 포스팅은 이 책을 공부한 내용의 정리로 진행될 예정이다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://seunghun-kim.github.io/categories/JavaScript/"},{"name":"Basic","slug":"JavaScript/Basic","permalink":"https://seunghun-kim.github.io/categories/JavaScript/Basic/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://seunghun-kim.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://seunghun-kim.github.io/tags/js/"}]},{"title":"JDBC (2) - getConnection()","slug":"jdbc-02","date":"2016-10-11T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2016/10/12/jdbc-02/","link":"","permalink":"https://seunghun-kim.github.io/2016/10/12/jdbc-02/","excerpt":"","text":"잡담처음 무언가를 배울때 ‘왜?’ 라는 궁금증이 중요하다. 이러한 궁금함이 없이 학습을 하다 보면 누군가로부터, 아니면 책으로부터 주는 지식을 아무 생각 없이 그대로 받아들이게 된다. 이게 나쁘지만은 않지만 ‘왜?’ 라는 생각을 시작함으로써 더 깊고 더 넓은 지식을 향해 나아갈 수 있다고 본다. Intro지난번 포스팅에서는 Class.forName(java.lang.String) 을 이용하여 JDBC Driver가 어떻게 동적으로 로딩 되는지 알아봤다. 자세한 사항은 지난 포스팅을 참고하면 된다. 이번에는 동적으로 로딩된 클래스를 어떻게 오브젝트화하여 사용하는지에 대해 알아보려고 한다. 사실 나도 잘 모른다. 지금부터 같이 알아보자. (해당 포스팅에 사용되는 DB는 CUBRID이며, 국산 오픈소스 DB이다. 필요하면 맘껏 갖다 쓰시기 바란다.) java.sql.Connection요 인터페이스는 JDBC Driver의 connection을 생성할 때 사용하는 인터페이스다. 낯이 많이 익을 것이다. 왜 인터페이스일까? 클래스면 바로 new Connection 해서 오브젝트 생성하면 될텐데! 라고 궁금해 하는 사람들이 있을텐데 (내가 옛날에 그랬지 ㅎ) 그건 다형성을 통해 클래스간 관심사를 분리해서 결합력을 낮추기 위해서 정도라고 생각하면 되겠다. 인터페이스는 여기까지 하고, 이놈은 인터페이스라 new 키워드를 이용해서 오브젝트를 생성하지 못한다. 그래서 우리는 java.sql.DriverManager 클래스를 이용해서 오브젝트를 생성한다. java.sql.DriverManagerjava api (8 기준)을 보면 getConnection 메소드는 총 3개가 존재한다. 123public static Connection getConnection(String url)public static Connection getConnection(String url, Properties info)public static Connection getConnection(String url, String user, String password) 위 3개 메소드는 public으로 내부에 노출되어 있다. 그럼 내부적으로 사용되는 무언가가 있을 것 같은 기분이 드는데? 소스… 소스를 까보자… 123456public static Connection getConnection(String url) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); return (getConnection(url, info, Reflection.getCallerClass()));&#125; 이건 인자가 하나뿐이고 내부에서 getConnection(url, info, Reflection.getCallerClass()) 를 호출한다. 다른거! 12345public static Connection getConnection(String url, java.util.Properties info) throws SQLException &#123; return (getConnection(url, info, Reflection.getCallerClass()));&#125; 인자 갯수만 늘어났지 동일한 행동을 한다. 또 다른거! 12345678910111213public static Connection getConnection(String url, String user, String password) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); if (user != null) &#123; info.put(\"user\", user); &#125; if (password != null) &#123; info.put(\"password\", password); &#125; return (getConnection(url, info, Reflection.getCallerClass()));&#125; 문자열 인자를 이용해서 Properties info를 만들고 동일한 행동을 한다. 그럼 우리가 궁금한 놈은 getConnection(url, info, Reflection.getCallerClass()) 이거다! 소스… 소스를 보자! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123; /* * When callerCl is null, we should check the application's * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if (callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(\"The url cannot be null\", \"08001\"); &#125; println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\"); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) &#123; try &#123; println(\" trying \" + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) &#123; // Success! println(\"getConnection returning \" + aDriver.driver.getClass().getName()); return (con); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; else &#123; println(\" skipping: \" + aDriver.getClass().getName()); &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println(\"getConnection failed: \" + reason); throw reason; &#125; println(\"getConnection: no suitable driver found for \"+ url); throw new SQLException(\"No suitable driver found for \"+ url, \"08001\");&#125; 전 포스트에서 본 것 같은 느낌은 기분탓이다. 메소드가 생각보다 기니깐 잘라서 한번 보자. 먼저 맨 윗부분 123456789101112131415private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123; /* * When callerCl is null, we should check the application's * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if (callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; 여기에서 ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; 이부분은 JDBC 4.0 스펙을 위해 추가된 소스코드이다. 실제로 JDK 7 소스코드에서는 해당 부분이 없다. 아래 내용은 JDBC 4.0 스펙에서 발췌한 글이다. 123■ Automatic loading of java.sql.DriverDriverManager.getConnection has been modified to utilize the Java SE Service Provider mechanism to automatically load JDBC Drivers. This removes the need to invoke Class.forName. Class.forName() 호출을 안해도 자동으로 Driver 클래스를 잡아준다. (우왕 개신기) 그 다음 볼 부분은 callerCL = Thread.currentThread().getContextClassLoader(); 이 부분인데 여기에서는 ClassLoader에 대한 배경지식이 필요하다. 간략하게 설명을 하자면, 전 포스팅에서 Class.forName()을 통해 JDBC Driver를 로딩하는데, 이때 로딩되면서 static 블록이 수행된다고 했다. 이 과정에서 DriverManager.registerDriver() 메소드가 수행되고, JDBC Driver가 오브젝트로 생성된다. 여기서 로딩된 클래스를 callerCL = Thread.currentThread().getContextClassLoader(); 를 통해 가져오는 것이다. (참 쉽죠?) 자, 그 다음 부분의 소스를 보자. 12345if(url == null) &#123; throw new SQLException(\"The url cannot be null\", \"08001\");&#125;println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\"); 파라미터로 넘어온 url을 확인한다. null이면 가차없이 SQLException을 던져버린다. 자, 그 다음 소스를 보자. 1234567891011121314151617181920212223242526// Walk through the loaded registeredDrivers attempting to make a connection.// Remember the first exception that gets raised so we can reraise it.SQLException reason = null;for(DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) &#123; try &#123; println(\" trying \" + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) &#123; // Success! println(\"getConnection returning \" + aDriver.driver.getClass().getName()); return (con); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; else &#123; println(\" skipping: \" + aDriver.getClass().getName()); &#125;&#125; 맨 위에 주석으로 친절히 설명을 해주고 있다. registerdDrivers를 로드했고 connection을 만든단다. 이부분! 이부분이 우리가 찾던 부분이다! 여기서 우리가 그동안 보지 못한 클래스가 하나 등장한다. DriverInfo, 이건 뭘까? 찾아보자. 1234567891011121314151617181920212223242526272829class DriverInfo &#123; final Driver driver; DriverAction da; DriverInfo(Driver driver, DriverAction action) &#123; this.driver = driver; da = action; &#125; @Override public boolean equals(Object other) &#123; return (other instanceof DriverInfo) &amp;&amp; this.driver == ((DriverInfo) other).driver; &#125; @Override public int hashCode() &#123; return driver.hashCode(); &#125; @Override public String toString() &#123; return (\"driver[className=\" + driver + \"]\"); &#125; DriverAction action() &#123; return da; &#125;&#125; DriverManager에 정의되어 있는 자료구조 클래스다. getConnection에서 for-loop을 돌면서 DriverInfo의 오브젝트를 하나씩 꺼내서 확인한다. isDriverAllowed(Driver driver, ClassLoader classLoader)는 첫 번째 파라미터 driver와 두 번째 파라미터 classLoader로부터 가져온 driver 오브젝트가 같으면 true, 다르면 false를 반환하는 메소드다. 정상적으로 같은 JDBC Driver를 로딩하고, 호출했다면 true가 반환되어 if 내 블록이 수행 될 것이다. 바로 Connection con = aDriver.driver.connect(url, info); 이부분! 이 부분은 벤더별로 specific 하게 구현된 부분이다. 왜냐하면 여기서 aDriver.driver는 특정 벤더의 JDBC Driver이기 때문이다. 우리는 오픈소스 DB CUBRID를 사용중이니 소스코드를 한번 까보자. cubrid.jdbc.driver.CUBRIDDriver123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public Connection connect(String url, Properties info) throws SQLException &#123; if (!acceptsURL(url)) &#123; return null; &#125; if (url.toLowerCase().startsWith(JDBC_DEFAULT_CONNECTION)) &#123; return defaultConnection(); &#125; Pattern pattern = Pattern.compile(URL_PATTERN, Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(url); if (!matcher.find()) &#123; throw new CUBRIDException(CUBRIDJDBCErrorCode.invalid_url, url, null); &#125; String match = matcher.group(); if (!match.equals(url)) &#123; throw new CUBRIDException(CUBRIDJDBCErrorCode.invalid_url, url, null); &#125; String dummy; String host = matcher.group(2); String portString = matcher.group(3); String db = matcher.group(4); String user = matcher.group(5); String pass = matcher.group(6); String prop = matcher.group(7); int port = default_port; UConnection u_con; String resolvedUrl; ConnectionProperties connProperties; if (host == null || host.length() == 0) &#123; host = default_hostname; &#125; if (portString == null || portString.length() == 0) &#123; port = default_port; &#125; else &#123; port = Integer.parseInt(portString); &#125; connProperties = new ConnectionProperties(); connProperties.setProperties(prop); // getting informations from the Properties object dummy = info.getProperty(\"user\"); if (dummy != null &amp;&amp; dummy.length() != 0) &#123; user = dummy; &#125; dummy = info.getProperty(\"password\"); if (dummy != null &amp;&amp; dummy.length() != 0) &#123; pass = dummy; &#125; if (user == null) &#123; user = default_user; &#125; if (pass == null) &#123; pass = default_password; &#125; resolvedUrl = \"jdbc:cubrid:\" + host + \":\" + port + \":\" + db + \":\" + user + \":********:\"; if (prop != null) &#123; resolvedUrl += prop; &#125; connProperties.setProperties(info); dummy = connProperties.getAltHosts(); if (dummy != null) &#123; ArrayList&lt;String&gt; altHostList = new ArrayList&lt;String&gt;(); altHostList.add(host + \":\" + port); StringTokenizer st = new StringTokenizer(dummy, \",\", false); while (st.hasMoreTokens()) &#123; altHostList.add(st.nextToken()); &#125; if (connProperties.getConnLoadBal()) &#123; Collections.shuffle(altHostList); &#125; try &#123; u_con = UJCIManager.connect(altHostList, db, user, pass, resolvedUrl); &#125; catch (CUBRIDException e) &#123; throw e; &#125; &#125; else &#123; try &#123; u_con = UJCIManager.connect(host, port, db, user, pass, resolvedUrl); &#125; catch (CUBRIDException e) &#123; throw e; &#125; &#125; u_con.setCharset(connProperties.getCharSet()); u_con.setZeroDateTimeBehavior(connProperties.getZeroDateTimeBehavior()); u_con.setConnectionProperties(connProperties); u_con.tryConnect(); return new CUBRIDConnection(u_con, url, user);&#125; 이부분도 굉장히 길다. 사실상 여기까지가 JDBC Driver의 Connection을 생성하는 부분의 끝이다. 여기서부터는 특정 벤더에 종속된 구현체이기 때문에 Oracle, MySQL, MS-SQL 뭐 다 다르다. 그래도 나는 궁금하니 소스를 끝까지 추적해 보겠다. (상관 없는 분은 여기서 작별 인사를…) 처음 소스코드를 보도록 하자. 123if (!acceptsURL(url)) &#123; return null;&#125; 아주 심플하다. url을 받아들일 수 있는 형태인지 확인한다. url의 헤더는 jdbc:cubrid로 시작하며, CUBRIDDriver.class.getName(); 를 호출하여 class의 이름을 확인한다. 만약, class가 oracle 또는 mysql이면 -oracle, -mysql을 헤더에 추가 후 :를 연결한다. 왜 이런 행동을 하냐면 CUBRID shard 기능 때문이다. 그리고 default connection이 있는데, 이부분은 Java stored procedure 를 사용하기 위해 필요하다. 자, 그럼 다음 소스코드를 보자. 123if (url.toLowerCase().startsWith(JDBC_DEFAULT_CONNECTION)) &#123; return defaultConnection();&#125; 바로 좀 전에 말했던 default connection을 반환하는 부분이다. 그 다음! 12345678910111213141516171819Pattern pattern = Pattern.compile(URL_PATTERN, Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(url); if (!matcher.find()) &#123; throw new CUBRIDException(CUBRIDJDBCErrorCode.invalid_url, url, null);&#125;String match = matcher.group();if (!match.equals(url)) &#123; throw new CUBRIDException(CUBRIDJDBCErrorCode.invalid_url, url, null);&#125;String dummy;String host = matcher.group(2);String portString = matcher.group(3);String db = matcher.group(4);String user = matcher.group(5);String pass = matcher.group(6);String prop = matcher.group(7);int port = default_port; 이부분은 뭘까?! 바로 URL 패턴을 분석하여 host ip, port, DB name, user id, user password, properties 값을 추출해내는 부분이다. 자, 다음 소스 코드! 123UConnection u_con;String resolvedUrl;ConnectionProperties connProperties; 변수 선언인데 아래 내용이 한 덩어리 기분이라 3줄만 보여줬다. 저 3개 변수가 마지막에 Connection 오브젝트를 생성하는데 지대한 영향을 끼칠 것이다. 자, 그럼 다음 소스! 123456789if (host == null || host.length() == 0) &#123; host = default_hostname;&#125;if (portString == null || portString.length() == 0) &#123; port = default_port;&#125; else &#123; port = Integer.parseInt(portString);&#125; host와 portString은 위의 url pattern을 파싱해서 가져온 값들이다. default_hostname은 localhost, default_port는 30000번을 의미한다. 12345678910111213141516171819connProperties = new ConnectionProperties();connProperties.setProperties(prop);// getting informations from the Properties objectdummy = info.getProperty(\"user\");if (dummy != null &amp;&amp; dummy.length() != 0) &#123; user = dummy;&#125;dummy = info.getProperty(\"password\");if (dummy != null &amp;&amp; dummy.length() != 0) &#123; pass = dummy;&#125;if (user == null) &#123; user = default_user;&#125;if (pass == null) &#123; pass = default_password;&#125; Connection 관련 properties를 prop 변수로부터 생성한다. 이게 뭐냐면 JDBC url 뒷부분에 ? 이후로 붙는 옵션이다. charset=utf8 이라던가 timeout=1 뭐 이런 것들이다. 그 다음에 갑자기 튀어 나온 info는 무엇일까?! 시간이 좀 지나서 잊어버렸을 지 모르지만 Connection con = aDriver.driver.connect(url, info); 를 통해 DriverManager에서 넘어온 info 저놈이다. 이 info는 값이 있을 수도 있고, null 일 수도 있다. getConnection() 어떤 애를 호출 했느냐에 따라 다르니깐 말이다. 그래서 if 문을 통해 user, password가 있는지 없는지 확인한다. null이면 기본 public 사용자에 password는 ‘’ (empty string)으로 세팅한다. 자, 다음 소스코드를 주세요! 1234resolvedUrl = \"jdbc:cubrid:\" + host + \":\" + port + \":\" + db + \":\" + user + \":********:\"; if (prop != null) &#123; resolvedUrl += prop;&#125; 자, 진짜 URL을 만들었다. 최종 형태는 “jdbc:cubrid:localhost:30000:demodb:public::” 이런 형태일 것이다. 그리고 맨 뒤에 Connection 관련 properties들을 붙혀준다. 아마 이런 형태일 것이다. (만약, prop 가 null이 아니라면 말이다.) “jdbc:cubrid:localhost:30000:demodb:public::?charset=utf8” 그 다음으로 넘어가자! 123456789101112131415161718192021222324252627connProperties.setProperties(info);dummy = connProperties.getAltHosts();if (dummy != null) &#123; ArrayList&lt;String&gt; altHostList = new ArrayList&lt;String&gt;(); altHostList.add(host + \":\" + port); StringTokenizer st = new StringTokenizer(dummy, \",\", false); while (st.hasMoreTokens()) &#123; altHostList.add(st.nextToken()); &#125; if (connProperties.getConnLoadBal()) &#123; Collections.shuffle(altHostList); &#125; try &#123; u_con = UJCIManager.connect(altHostList, db, user, pass, resolvedUrl); &#125; catch (CUBRIDException e) &#123; throw e; &#125;&#125; else &#123; try &#123; u_con = UJCIManager.connect(host, port, db, user, pass, resolvedUrl); &#125; catch (CUBRIDException e) &#123; throw e; &#125;&#125; 먼저 connProperties.setProperties(info)를 수행하는데, 별거 없다. info에는 있어봤자 user, password 정도이거나 빈 오브젝트일 것이다. 그 다음 나오는 dummy = connProperties.getAltHosts();가 뭔지는 CUBRID에 대해 아는 사람만 알 것이다. 바로, High Availability(HA)를 위해 DB 이중화를 하기 위해 다른 노드의 접속 정보를 기입하는 프로퍼티이다. 여기에서 dummy 변수의 값이 null이 아니라면, JDBC Connection properties 들 중 altHosts라는 내용이 있다는 뜻이다. 그럼 HA 구성을 사용한다는 의미이고, failover를 위해 2개 이상의 노드 정보를 생성해야한다. 그 부분이 바로 while이 돌면서 만들어 내는 부분이다. 그 다음 라인을 보면 if (connProperties.getConnLoadBal()) { 이런 코드를 수행하는데 (메소드 명이 사실 좀 헷갈리게 되있는건 기분탓?) HA 구성에서 loadBalance를 사용할지에 대한 프로퍼티를 지정하는 부분이다. 랜덤한 순서로 연결하도록 한다고 메뉴얼에 되어 있는데 그래서 Collections.shuffles()로 섞어주나보다. 다음 나오는 오브젝트는 u_con 이다. 이게 사실 직접적으로 DB에 connection을 맺어주는 오브젝트이다. cubrid.jdbc.jci 패키지에 위치하며, 약 2처라인 좀 넘는데 바이트를 주로 다룬다. (왠지 멋지다… 개발자는 비트 바이트 이래야지) 자, 아무튼, connect 부분 소스코드를 보면 사실 별거 없다. 파라미터에 맞게 UConnection 을 생성하여 반환하면 끝. 12345678910111213141516171819public static UConnection connect(String ip, int port, String name, String user, String passwd, String url) throws java.sql.SQLException &#123; UConnection connection; connection = new UConnection(ip, port, name, user, passwd, url); // connectionList.add(connection); return connection;&#125;public static UConnection connect(ArrayList&lt;String&gt; aConList, String name, String user, String passwd, String url) throws java.sql.SQLException &#123; UConnection connection; connection = new UConnection(aConList, name, user, passwd, url); // connectionList.add(connection); return connection;&#125; 이제 CUBRID의 JDBC Driver를 사용하기 위한 Connection 오브젝트 생성이 완료되었다. 마지막으로 몇 가지만 더 하고 반환하자. 12345u_con.setCharset(connProperties.getCharSet());u_con.setZeroDateTimeBehavior(connProperties.getZeroDateTimeBehavior());u_con.setConnectionProperties(connProperties);u_con.tryConnect(); Connection 오브젝트에 set 뭐시기를 하는거 보니 값을 설정하는 것 같다. u_con.setCharset()은 뭐 말 안해도 알꺼 같다. 문자셋을 프로퍼티에 지정한다. u_con.setZeroDateTimeBehavior()는 뭘까? JDBC에서는 java.sql.Date 형 오브젝트에 날짜와 시간 값이 모두 0인 값을 허용하지 않는다. default 동작은 Exception 발생이다. 까지만 알면 될 것 같다. u_con.setConnectionProperties()는 지금껏 만든 connProperties 오브젝트를 u_con 오브젝트에 넣어주는 역할이다. 그리고, 마지막 u_con.tryConnect()는 DB에 직접적인 connect를 시도하는 메소드이다. 내부에서 이것 저것 불리다가 private void connectDB(int timeout) throws IOException, UJciException 이런 메소드가 호출되어 DB와 연결된다. (이 부분은 나중에 시간 나면 자세히 포스팅 하겠다) 마지막으로 반환! 1return new CUBRIDConnection(u_con, url, user); u_con은 바로 위에서 만들었고, url도 이쁘게 만들었고, user는 matcher로 뽑아왔던애가 있었다. 이 3개를 가지고 CUBRIDConnection 생성자를 호출하여 오브젝트를 생성하면 끝! 끝으로너무 두서 없이 썼다. 나 아니면 아무도 못 알아볼지도 모른다. 너무 허접하다. 다른 사람의 소스코드를 보는건 재밌다. 그리고 놀랍다. 그리고 갈길이 너무 멀다. ^^","categories":[{"name":"Java","slug":"Java","permalink":"https://seunghun-kim.github.io/categories/Java/"},{"name":"JDBC","slug":"Java/JDBC","permalink":"https://seunghun-kim.github.io/categories/Java/JDBC/"}],"tags":[{"name":"java","slug":"java","permalink":"https://seunghun-kim.github.io/tags/java/"},{"name":"jdbc","slug":"jdbc","permalink":"https://seunghun-kim.github.io/tags/jdbc/"}]},{"title":"Clean Code (2)","slug":"cleancode-02","date":"2016-10-10T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2016/10/11/cleancode-02/","link":"","permalink":"https://seunghun-kim.github.io/2016/10/11/cleancode-02/","excerpt":"","text":"intro어제 mac os를 sierra 로 업데이트 했다. desktop용으로 siri도 생기고, 한글 쓸 때 capslock으로 변경이 되고, 작업중 윈도우를 작게 변경해서(?) 뭐 이런 기능들이 새로 생긴 것 같다. 그리고 Mail app에서 인증서가 신원을 확인할 수 없는 서버라며 승인이 안되는 문제도 있었다…. (인터넷 찾아보니 인증서를 항상 신뢰 하도록 체크만 해주면 되는 문제였다… ㅎ) 자, 아무튼 이번에는 이름 선정에 대한 내용이다. (모든 소스코드는 Clean Code 책 내에 포함된 소스코드 입니다. 전 아무런 저작권이 없답니다… ^^) 그리고 스크롤 압박이 심하니 주의하시기 바랍니다. 의도를 분명하게 하라말은 쉽다. 의도가 무엇인지 분명해야 보는 사람으로 하여금 스무~스 하게 이해하고 지나갈 수 있다. 근데 이게 말처럼 쉽지가 않다. 좋은 이름을 지으면 작명하는데 시간이 오래 걸리지만, 그로 인해 앞으로 사용할 때 시간을 절약할 수 있다. (올커니!) 이런 예를 한번 보자. 1int d; // 경과 시간(단위: 날짜) d 의 의도를 알겠는가? 안다면 너님이 지으신 변수 일 것이다. 이런 작명은 땡이다. 아주. 완전히. 땡! 아래와 같이 짓는게 무릎을 탁! 치게 만든다. 1234int elapsedTimeInDays;int daysSinceCreation;int daysSinceModification;int fileAgeInDays; 자, 주석 따위 없어도 요놈이 무엇을 하는지 감이 온다. 잘 지었다. 이제 위와 같은 잘못된 작명으로 인한 예제를 한번 보자. 1234567public List&lt;int[]&gt; getThem() &#123; List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;(); for (int[] x : theList) if (x[0] == 4) list1.add(x); return list1;&#125; 혼란스럽다. x의 첫 번째 요소의 값이 4이면 ArrayList로 저장해서 반환하는건데 뭣땜에 첫 번째 요소가 4여야하고, 반환하는지 모르겠다. 위 메소드를 예쁜 작명으로 아래와 같이 바꿔보자. 1234567public List&lt;int[]&gt; getFlaggedCells() &#123; List&lt;int[]&gt; flaggedCells = new ArrayList&lt;int[]&gt;(); for (int[] cell : gameBoard) if (cell[STATUS_VALUE] == FLAGGED) flaggedCells.add(cell); return flaggedCells;&#125; 위의 소스코드는 같은 일을 한다. (로직도 같다) 하지만 아래 예제는 무슨 일을 하는지 짐작이 가지 않는가? (안간다면 반복해서 보시면 된다) 내가 두 번째 소스코드를 보고 느낀 느낌은 이렇다. 메소드 이름에서 flag가 설정된 cell을 반환할 거 같다. flaggedCells라는 ArrayList는 falg가 설정된 cell들이 들어 있을 것 같다. gameBoard라는 변수는 왠지 게임 판때기를 뜻할 것 같다. for-loop을 돌면서 gameBoard에서 뽑아낸 cell 이라는 배열은 cell의 상태값을 저장하는거 같다. cell의 상태가 FALGGED (상수겠지?) 라면 flaggedCells에 저장해서 리턴할 것 같다. 분명 같은 행위를 하는 메소드인데, 변수 이름만 바꿨을 뿐인데, 굉장히 많은 정보를 알게 되었다. (개신기!) 다음은 위의 소스코드를 클래스를 통해 바꾼 예제도 있다. 한번 감상해 보시라. 1234567public List&lt;Cell&gt; getFlaggedCells() &#123; flaggedCells = new ArrayList&lt;Cell&gt;(); for (Cell cell : gameBoard) if (cell.isFlaged()) flaggedCells.add(cell); return flaggedCells;&#125; 그릇된 정보를 피하라나름대로 널리 쓰이는 의미 있는 단어들은 가능하면 피하는게 좋겠다. 예를 들면, 직각삼각형의 빗변이 영어로 hypotenuse라고 변수명으로 int hp 해버리면 hp를 보고 컴퓨터 회사를 떠올릴 지도 모른다. (아님 말고 ㅎ) 또한 이건 내가 자주 쓰던 패턴이었는데 책에선 피하라고 적혀 있었다. 여러 값들을 하나로 묶을 때 List라는 단어를 생각해서 int AccountList 와 같은 형태로 변수를 짓지 않는게 좋단다. List는 개발자에게 의미있게 널리 쓰이는 단어이기 때문이다. 또한 서로 흡사한 이름은 사용하지 말라고 당부하고 있다. 예를 들면 XYZControllerForEfficientHandlingOfString``` 12345678910111213이라는 변수와 조금 떨어진 곳에서 ```String XYZControllerForEfficientStorageOfString``` 이렇게 쓰면 겁나 헷갈리기 때문이다. (내가 예전에 이렇게 썼다가 머리에 쥐날 뻔 했다 ㅎ)그리고 소문자 L과 대문자 O (숫자 0 아님에 주의) 사용에 주의해야 한다. l은 1처럼 보이고, O는 0 처럼 보인다.```javaint a = 1;if (O == 1) a = Ol;else l = 01; 보기만 해도 속 터진다. 의미 있게 구문하라동일한 클래스 내에서, 비슷한 개념의 두 객체에 대해, 어떻게 이름을 지어야 잘 했다고 소문이 날 까 고민을 해본 경험이 있을 것이다. (class가 있으니 klass라고 짓자. 뭐야 이건!) 에라 모르겠다, 숫자만 바꾸자. 1234public static void copyChars(char a1[], char a2[]) &#123; for (int i = 0; i &lt; a1.length; i++) a2[i] = a1[i];&#125; 그래. 메소드 이름을 보니 character를 copy 한다는 건 알겠다. 근데 어떤 놈을 어떤 놈에게 copy하는 걸까? 이렇게 바꿔보자. 1234public static void copyChars(char source[], char destination[]) &#123; for (int i = 0; i &lt; source.length; i++) destination[i] = source[i];&#125; 좀 더 명확해졌다. (무릎 탁!) 불용어 라는 단어가 등장하는데 영어로는 noise word 되시겠다. 느낌이 오는가? 쓰면 될까 안될까? 이런 느낌이다. Object ProductInfo와 Object ProductData 둘 중 차이점을 알겠는가? Object zork 와 Object theZork의 차이점을 알겠는가? 읽는 사람이 차이를 알도록 이름을 짓는게 중요하다. 발음하기 쉬운 이름을 사용하라말 그대로 발음하기 쉬운 단어들을 변수명 혹은 클래스, 메소드 기타 등등 이름으로 지으면 된다. 1int bcr3cntepsgq; 이거 어떻게 읽을꺼니? 이런 예제도 한번 보자 123456class DtaRcrd102 &#123; private Date genymdhms; private Date modymdhms; private final String pszqint = \"102\"; /* ... */&#125; 신입 개발자: 제니므드흠스 변수는 대체 뭔가요? 123456class Customer &#123; private Date generationTimestamp; private Date modificationTimestamp; private final String recordId = \"102\"; /* ... */&#125; 두 번째 예제 코드를 이용하면 개발자들끼리 서로 지적인 대화가 가능해진다. 신입 개발자: 제너레이션타임이 최초 생성된 시간을 의미하겠군요. 아하! (무릎 탁!) 시니어 개발자: 그렇지! 검색하기 쉬운 이름을 사용하라예를 들면 (설마 이러진 않겠지만) 변수 명을 int e 라고 선언했고, 중요한 변수라고 치면 이 변수는 검색으로 어떻게 찾을 것인가? 이러한 한 글짜나 짧은 변수명은 로컬 변수로 잠깐 사용하고 말 때만 쓰는게 좋다. for-loop에서 쓸 int i 라던가. 여기서 한가지 팁은 이름 길이는 범위 크기에 비례해야 한다. 라고 한다. 길이가 길면 찾기도 수월할테니 말이다. 아래 예제를 보자. 123for (int j = 0; j &lt; 34; j++) &#123; s += (t[j] * 4) / 5;&#125; 뭐야 이게 (짜증이 밀려온다.) 12345678int realDaysPerIdealDay = 4;const int WORK_DAYS_PER_WEEK = 5;int sum = 0;for (int j = 0; j &lt; NUMBER_OF_TASKS; j++) &#123; int realTaskDays = taskEstimate[j] * realDaysPerIdealDay; int realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK); sum += realTaskWees;&#125; 두 소스코드를 비교하면 아래 소스코드가 훨씬 이해하기 좋다. (두 번째가 더 많은 선언이 보여서 그렇다면 기분탓?) 5를 검색 하는 것 보다는 WORK_DAYS_PER_WEEK 을 검색하는게 더 좋다. 인코딩을 피하라여기서 인코딩은 변수명을 암호화 하지 말라는 의미 인 것 같다. (UTF-8을 euc-kr로 바꾼다거나 이런 거창한게 아닌듯) 그러면서 헝가리안 표기법이 나오는데, 요즘엔 언어도 많이 발달하고 IDE도 발달해서 타입이 뭔지 바로 알 수 있으니깐 안쓰는게 덜 복잡하다. 예제를 한번 보면 12345public class Part &#123; private String m_dsc; // 설명 문자열 void setName(String name) &#123;m_dsc = name; &#125;&#125; 의미는 알겠으니 큰 상관은 없겠으나 m_ 이라는 접두사는 살짝 거슬리는건 기분탓? 123456public class Part &#123; String description; void setDescription(String description) &#123; this.description = description; &#125;&#125; 이게 조금 더 명확한 기분이다. 추가로, 인터페이스 이름을 지을 때에도 앞에 ‘I’를 접두사로 붙히곤 한다. 근데 굳이… 그럴 필요가 있을까? 느슨한 연결을 위해 인터페이스를 사용하는데 굳이 I를 붙혀서 ‘나 인터페이스지롱~’ 할 필요는 없을 것 같다. 는게 저자의 마인드. 차라리 구현 클래스에 접미사로 impl을 붙히는게 낫다고 한다. 자기 기억력을 자랑하지 마라다른 사람의 코드를 읽는데 변수 이름이 이해가 안되서 뭔가 다른 이름으로 변환해야 한다면… 잘못 된 변수명이다. (당연하잖아?) 또한, 나는 url을 r 이라는 변수명으로 지어서 써야지~ 하고 프로그램 전체에 걸쳐 r을 이용해 10만라인짜리 소스코드를 뚝딱뚝딱 만들었다. (r 이 뭔지 안헷갈렸다면 당신은 굉장히 똑똑하다) 근데 이러면 다른 사람이 코드를 읽는데 r이 뭐하는 놈인지 자꾸 확인하면서 소스코드를 읽어야 할 것이다. (아 귀찮게 말이야) 똑똑한 개발자와 전문 개발자사이의 차이점은 명료함이 최고 라고 한다. (r 은 명료하다기 보단 걍 귀차니즘 같은 스멜) 클래스 이름클래스 이름과 객체 이름은 명사 혹은 명사구를 이용한다. (동사는 메서드에게 양보하세요) 메서드 이름메서드 이름은 동사 혹은 동사구가 적합하다. (명사는 클래스에게 양보하세요) 접근자(Accessor), 변경자(Mutator), 조건자(Predicate) 는 javabean 표준에 따라 앞에 get, set, is 를 붙인다. 123String name = employee.getName();customer.setName(\"Hun\");if (paycheck.isPosted())... 그리고 생성자(Constructor)를 중복 정의(Overload) 할 경우에는 정적 팩토리 메소드(static factory method)를 이용하라는 꿀팁도 있다. 1Complex fulcrumPoint = new Complex(23.0); 보다는 1Complex fulcrumPoint = Complex.FromRealNumber(23.0); 이 더 명확하다. 기발한 이름은 피하라유머 센스가 넘쳐 흐르는 개발자라서 kill() 메소드를 whack() 이라고 표현할 수 있다. 하지만 일반적인 사람들은 whack()이 뭔지 모를 것이다. 의도를 분명하고 솔직하게 표현하는게 짱. 한 개념에 한 단어를 사용하라추상적인 개념 하나에 단어 하나를 선택하고 이를 고수해야 한다. (고수가 아니라 이 고수다.) 예를 들어 데이터를 가져오는 메소드의 명칭을 어디선 fetch, 어디선 retrieve, 어디선 get 이래버리면 소스코드를 트래킹 할 때마다 짜증이 밀려올 것이다. (시간 소모는 덤) 말장난을 하지 마라다른 개념에 같은 단어를 사용한다면, 이게 말장난이라고 언급하고 있다. (다른 개념인데 이름이 같으면 같은 애라고 착각을 일으킬 것이다. 적어도 나는 그래.) 좋은 코드는 집중적인 탐구가 필요한 코드가 아니라 대충 훑어봐도 이해할 코드 이다. 해법 영역에서 가져온 이름을 사용하라문제 영역과 해법 영역을 분리해서 설명하고 있다. 문제 영역은 해당 기능의 구현이 필요한 곳. 즉, 문제가 발생한 곳을 의미하고, 해법 영역은 문제 영역에서 발생한 문제들을 해결하기 위한 해법들이 있는 영역을 의미한다. 그렇다면 해법 영역에서 가져온 이름이란 놈들의 예를 들어보면, 우리는 개발자니깐 전산 용어들을 많이 알고 있을 것이다. jobQeue, stack, list 이런 애들이 해법 영역에서 가져온 이름이 된다. 문제 영역에서 가져온 이름을 사용하라만약, 위에서 언급한 해법 영역에서 가져올 만한 이름이 없다면? 차선책으로 문제 영역에서 가져온 이름을 사용하면 된다. 모르는 단어가 나오면 해당 업무 담당자나 전문가에게 물어봐서 의미를 파악하면 된다. (이건 귀찮네) 그리고, 문제 영역 개념과 관련이 깊은 코드라면, 문제 영역에서 이름을 가져오는게 맞다. 의미 있는 맥락을 추가하라아래와 같은 변수들이 있다. 1234567String firstName;String lastName;String street;int houseNumber;String city;String state;int zipcode; 뭐하는 변수인지 감이 온다. 바로 주.소. 같지 아니한가? 근데 만약, String state 하나만 떼어놓고 본다면, 과연 주소라고 생각할 수 있을까? 이럴 경우 명확한 맥락을 위해 접두사를 아래와 같이 붙혀보자. 1234567String addrFirstName;String addrLastName;String addrStreet;int addrHouseNumber;String addrCity;String addrState;int addrZipcode; 이제 String addrState 하나만 갖다 써도 아! 주소구나! 라고 알 수 있을 거다. 또 한가지 예를 보자. 이 경우는 메소드 명은 일부 맥락만을 제공하고, 코드를 모두 읽으면 알고리즘을 통해 맥락을 파악할 수 있다. 12345678910111213141516171819202122private void printGuessStatistics(char candidate, int count) &#123; String number; String verb; String pluralModifier; if (count == 0) &#123; number = \"no\"; verb = \"are\"; pluralModifier = \"s\"; &#125; else if (count == 1) &#123; number = \"1\"; verb = \"is\"; pluralModifier = \"\"; &#125; else &#123; number = Integer.toString(count); verb = \"are\"; pluralModifier = \"s\"; &#125; String guessMessage = String.format( \"There %s %s %s%s\", verb, number, candidate, pluralModifier ); print(guessMessage);&#125; 이해를 돕기 위해, (바로 내 이해) 영어 단어 몇개의 뜻을 아래에 적어둔다. (아 영어 제길) 12candidate: 후보plural: n. 복수, a. 복수형의 위 소스코드는 String guessMessage 이부분이랑 잘 엮어서 봐야 무슨 일을 하는 메소드인지 명확해진다. (잘 모르겠으면 알때까지 보자) 위 예제를 클래스로 만들어서 if 구문을 각각의 메소드로 분리했다. 좀더 보기 좋은 맥락을 위해!! 12345678910111213141516171819202122232425262728293031323334353637383940public class GuessStatisticsMessage &#123; private String number; private String verb; private String pluralModifier; public String make(char candidate, int count) &#123; createPluralDependentMessageParts(count); return String.foramt( \"There %s %s %s%s\", verb, number, candidate, pluralModifier); &#125; private void createPluralDependentMessageParts(int count) &#123; if (count == 0) &#123; thereAreNoLetters(); &#125; else if (count == 1) &#123; thereIsOneLetter(); &#125; else &#123; thereAreManyLetters(count); &#125; &#125; private void thereAreManyLetters(int count) &#123; number = Integer.toString(count); verb = \"are\"; pluralModifier = \"s\"; &#125; private void thereIsOneLetter() &#123; number = \"1\"; verb = \"is\"; pluralModifier = \"\"; &#125; private void thereAreNoLetters() &#123; number = \"no\"; verb = \"are\"; pluralModifier = \"s\"; &#125;&#125; 불필요한 맥락을 없애라일반적으로 짧은 이름이 긴 이름보다 좋다. 단, 의미가 분명한 경우에 한해서 말이다. 즉, 이름에 불필요한 맥락을 추가하지 않도록 주의하자. accountAddress와 customerAddress는 Address 클래스의 인스턴스로는 괜찮다. 하지만 클래스 이름으론 빵점이다 빵점! 결론우리는 영어로 코드를 만든다. (물론 한글로 변수명, 클래스명을 만들어도 돌아는 간다.) 그럼 역시 영어를 잘 해야 한다. 영어 공부 하자.","categories":[{"name":"Code","slug":"Code","permalink":"https://seunghun-kim.github.io/categories/Code/"},{"name":"CleanCode","slug":"Code/CleanCode","permalink":"https://seunghun-kim.github.io/categories/Code/CleanCode/"}],"tags":[{"name":"cleancode","slug":"cleancode","permalink":"https://seunghun-kim.github.io/tags/cleancode/"},{"name":"code","slug":"code","permalink":"https://seunghun-kim.github.io/tags/code/"},{"name":"wording","slug":"wording","permalink":"https://seunghun-kim.github.io/tags/wording/"}]},{"title":"Clean Code (1)","slug":"cleancode-01","date":"2016-10-09T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2016/10/10/cleancode-01/","link":"","permalink":"https://seunghun-kim.github.io/2016/10/10/cleancode-01/","excerpt":"","text":"잡담예전부터 Clean Code 를 보려고 몇 번이나 도서관에서 책을 빌렸지만 미루다 보니 여태까지 못 보고 있었다. 이제 더는 안되겠다 싶어 무조건 끝까지 읽어보자고 다짐을 했고, 도서관 간김에 Clean Code를 다시 빌려왔다. 그리고는 동기 부여를 위해서 읽은 내용들을 정리해서 블로그에 포스팅 하기로 하였다. 이 포스팅이 바로 그 시작점이다. Intro이 부분은 주로 깨끗한 코드(Clean Code)가 무엇인지 설명하고 있다. 아마도 이 책 전체에 걸친 내용을 가장 간략하게 설명한 부분이 아닐까 싶다. (당연한가? ㅎ) 또한 앞으로 어떠한 방법으로 깨끗한 코드에 대해 알아갈 것인지에 대한 방향을 암시한다. 가벼운 마음으로 이 책을 읽고 넘어가는 것이 아니라, 빡세게 공부하듯 읽으라고 당부하고 있다. (앞 내용인가? ㅎ) 나쁜 코드나쁜 코드가 가져다주는 재앙에 대해 말해주고 있다. 간단하다. 덩치가 커진 얽힌 실타래는 결국 풀지 못하고 가위로 잘라내야 한다. 애초에 나쁜 코드가 되지 않게 잘 만들어 가야 한다. 태도 &amp; 원초적 난제여기서 전문가가 되기 위한 마인드를 언급하고 있다. 다음과 같이 머리에 쏙쏙 들어오는 예를 통해서! 1234567자신이 의사라 가정하자. 어느 환자가 수술 전에 손을 씻지 말라고 요구한다. 시간이 너무 걸리니까. 확실히 환자는 상사다. 하지만 의사는 단호하게 거부한다. 왜? 질병과 감염의 위험은 환자보다 의사가 더 잘 아니까. 환자 말을 그대로 따르는 행동은 (범죄일 분만 아니라) 전문가답지 못하니까. 전문가 답지 못하니까!! 나쁜 코드의 위험을 알면서, 상사가 얼른 개발하라고 했다고 대충 만드는건 위험하다! 전문가 답지 못하다! (짤리느냐 자존심을 지키느냐 문제인가… ㅋ) 하지만 시간이 없다고 나쁜 코드를 양산하면 다음번에 발목을 잡힐 수 밖에 없다. 무조건 깨끗한 코드를 유지하는 습관이 중요하다! 라고 언급하고 있다. 깨끗한 코드란?여기에서는 유명하고 훌륭한 개발자분들의 의견을 언급하며 깨끗한 코드란 무엇인지 설명하고 있다. 책을 읽으면서 몇 가지 정리된 내용을 정리하자면 깨끗한 코드란 보기에 즐거운 코드이다. (마치 예술 작품을 구경하는 듯하게) 나쁜 코드는 나쁜 코드를 유혹한다. (나쁜 코드를 고치면서 더 나쁜 코드를 양산한다) 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리한다. 깨끗한 코드는 한 가지 일에만 집중한다. 깨끗한 코드는 잘 쓴 문장처럼 읽혀야 한다. 깨끗한 코드는 다른 사람이 고치기 쉽다. (읽기 쉬운 코드와 고치기 쉬운 코드는 다르다) 테스트케이스가 없는 코드는 깨끗한 코드가 아니다. 깨끗한 코드는 고칠 곳이 없도록 주의 깊게 작성된 코드이다. 깨끗한 코드는 짐작했던 기능을 각 루틴이 그대로 수행한다. 그리고 다음과 같은 규칙을 언급했다. 보이스카우트 규칙: 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라. 무슨 말이냐! 바로 pull 할 때 보다 좀 더 깨끗한 코드를 push 하라는 말이다. 그러면 자연스럽게 코드는 깨끗해질 수 밖에 없다. 결론다들 알고 있지만 실천하지 못한 사소한 내용들을 언급하고 있다. 보다 전문가가 되기 위해 이러한 내용들을 머리가 아닌 몸에 새기도록 노력해야겠다.","categories":[{"name":"Code","slug":"Code","permalink":"https://seunghun-kim.github.io/categories/Code/"},{"name":"CleanCode","slug":"Code/CleanCode","permalink":"https://seunghun-kim.github.io/categories/Code/CleanCode/"}],"tags":[{"name":"cleancode","slug":"cleancode","permalink":"https://seunghun-kim.github.io/tags/cleancode/"},{"name":"code","slug":"code","permalink":"https://seunghun-kim.github.io/tags/code/"}]},{"title":"JDBC (1) - Class.forName(java.lang.String)?!","slug":"class_for_name","date":"2016-10-06T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2016/10/07/class_for_name/","link":"","permalink":"https://seunghun-kim.github.io/2016/10/07/class_for_name/","excerpt":"","text":"JDBC Driver를 사용할 경우, Connection을 생성하기 전에 Class.forName(&quot;Specific Vender&#39;s Driver&quot;); 코드를 추가해서 사용할 JDBC Driver를 로드해야 한다. 얘는 뭘 하는 앨까? 호출되는 코드만 봐서는 직관적로 뭘 하는지 잘 모르겠다. 한번 찾아보자! java.lang.Class1234567891011121314151617181920public final class Class&lt;T&gt;extends Objectimplements Serializable, GenericDeclaration, Type, AnnotatedElementInstances of the class Class represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects.Class has no public constructor. Instead Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader.The following example uses a Class object to print the class name of an object: void printClassName(Object obj) &#123; System.out.println(&quot;The class of &quot; + obj + &quot; is &quot; + obj.getClass().getName()); &#125; It is also possible to get the Class object for a named type (or for void) using a class literal. See Section 15.8.2 of The Java™ Language Specification. For example:System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());Since:JDK1.0See Also:ClassLoader.defineClass(byte[], int, int), Serialized Form Class 클래스의 인스턴스이며 러닝 타임의 클래스들과 인터페이스들을 표현한다고 한다. 그리고 primitive 타입과 void 도 Class 오브젝트로 표현된다고 한다.(enum은 클래스중 한 종류이고, annotation은 인터페이스의 한 종류인건 안비밀 ㅎ) 자 그럼 forName 메소드를 한번 봐보자. forName(java.lang.String)123456789101112131415161718public static Class&lt;?&gt; forName(String className) throws ClassNotFoundExceptionReturns the Class object associated with the class or interface with the given string name. Invoking this method is equivalent to:Class.forName(className, true, currentLoader)where currentLoader denotes the defining class loader of the current class.For example, the following code fragment returns the runtime Class descriptor for the class named java.lang.Thread:Class t = Class.forName(&quot;java.lang.Thread&quot;)A call to forName(&quot;X&quot;) causes the class named X to be initialized.Parameters:className - the fully qualified name of the desired class.Returns:the Class object for the class with the specified name.Throws:LinkageError - if the linkage failsExceptionInInitializerError - if the initialization provoked by this method failsClassNotFoundException - if the class cannot be located 문자열 파라미터로 전달된 애와 연관된 클래스 혹은 인터페이스의 Class 오브젝트를 반환한다. (Class 오브젝트를 반환하지 문자열에 해당하는 클래스를 반환하는게 아니다!) 오브젝트를 리턴하는데… 보통 JDBC Driver를 사용할 때 Class.forName() 메소드를 따로 변수에 저장하지 않고 그냥 호출만 한다. 그냥 공중에다가 오브젝트를 뿌려버리고 마는 걸까? (에이 설마 ㅎ) 이부분은 JDBC Driver의 소스코드를 봐야 알 것 같다. 말 나온김에 한번 봐보자! 소스코드는 CUBRID JDBC Driver를 보기로 했다. (MySQL, Oracle 다 비슷비슷 할거 같다. 왜? 표준이란게 있으니깐) CUBRID는 JDBC Driver를 로딩할 때 Class.forName(&quot;cubrid.jdbc.driver.CUBRIDDriver&quot;); 이렇게 호출한다. 즉, cubrid.jdbc.driver.CUBRIDDriver 라는 클래스를 로드하여 반환하라는 의미이다. 이때, 우리는 따로 변수에 담지 않으니깐 저게 호출되면서 무엇을 하는지를 알아봐야 할 것이다.(소스.. 소스를 보자!) 소스코드는 github에 올라와 있으니 필요하신 분은 참고하시길… cubrid.jdbc.driver.CUBRIRDDriver.java1234567891011121314151617181920212223public class CUBRIDDriver implements Driver &#123; // version public static final String version_string = \"@JDBC_DRIVER_VERSION_STRING@\"; public static final int major_version; public static final int minor_version; public static final int patch_version; static &#123; StringTokenizer st = new StringTokenizer(version_string, \".\"); if (st.countTokens() != 4) &#123; throw new RuntimeException(\"Could not parse version_string: \" + version_string); &#125; major_version = Integer.parseInt(st.nextToken()); minor_version = Integer.parseInt(st.nextToken()); patch_version = Integer.parseInt(st.nextToken()); &#125;... (생략) static &#123; try &#123; DriverManager.registerDriver(new CUBRIDDriver()); &#125; catch (SQLException e) &#123; &#125; &#125; 여기서 눈여겨 볼 곳은 static 블록이다. static 블록이 왜 중요하냐고? 클래스가 로딩 되면 static 관련 애들은 JVM의 method 영역으로 올라가게 된다.따라서 static 이 붙은 애들은 클래스가 로딩되는 시점부터 사용할 준비가 되는 것이다. 처음 static 블록은 그냥 버전 정보를 저장할 뿐이니깐 패스하고 두 번째 static 블록을 보면 실질적으로 CUBRIDDriver 오브젝트를 등록하는 코드가 보인다.(이부분은 MySQL, Oracle 등 다 같을 것이다. 표준이니깐) 그럼 여기서 registerDriver(java.sql.Driver)는 뭘 하는 애일까? 그냥 등록만 하면 끝인가? 궁금하다! registerDriver(java.sql.Driver)1234567891011121314151617/** * Registers the given driver with the &#123;@code DriverManager&#125;. * A newly-loaded driver class should call * the method &#123;@code registerDriver&#125; to make itself * known to the &#123;@code DriverManager&#125;. If the driver is currently * registered, no action is taken. * * @param driver the new JDBC Driver that is to be registered with the * &#123;@code DriverManager&#125; * @exception SQLException if a database access error occurs * @exception NullPointerException if &#123;@code driver&#125; is null */public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123; registerDriver(driver, null);&#125; 앗, registerDriver(driver, null); 을 호출한다. 이걸 찾아가보자. registerDriver(java.sql.Driver, java.sql.DriverAction)123456789101112131415161718192021222324252627282930/** * Registers the given driver with the &#123;@code DriverManager&#125;. * A newly-loaded driver class should call * the method &#123;@code registerDriver&#125; to make itself * known to the &#123;@code DriverManager&#125;. If the driver is currently * registered, no action is taken. * * @param driver the new JDBC Driver that is to be registered with the * &#123;@code DriverManager&#125; * @param da the &#123;@code DriverAction&#125; implementation to be used when * &#123;@code DriverManager#deregisterDriver&#125; is called * @exception SQLException if a database access error occurs * @exception NullPointerException if &#123;@code driver&#125; is null * @since 1.8 */public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; /* Register the driver if it has not already been added to our list */ if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#125; else &#123; // This is for compatibility with the original DriverManager throw new NullPointerException(); &#125; println(\"registerDriver: \" + driver);&#125; 자, 보니깐 registerdDrivers 라는 변수에 새로운 드라이버 정보가 저장되는걸 볼 수 있다. (이 변수는 thread-safe ArrayList이고, DriverInfo가 없을 경우만 add 한다) 그럼 registerdDrivers에 저장된 변수는 언제 어떻게 사용이 될까?? 곰곰히 생각해보자. Class.forName() 을 호출하고 나서 뭘 했지?! 바로 DriverManager.getConnection(&quot;Specific vender&#39;s url&quot;); 이런 코드를 입력했을 것이다. 바로, Connection 오브젝트를 생성하는 단계이다. 이때 과연 무슨 일이 일어날까?? (소스… 소스를 보자!) DriverManager.getConnection123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Worker method called by the public getConnection() methods.private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123; /* * When callerCl is null, we should check the application's * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if (callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(\"The url cannot be null\", \"08001\"); &#125; println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\"); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) &#123; try &#123; println(\" trying \" + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) &#123; // Success! println(\"getConnection returning \" + aDriver.driver.getClass().getName()); return (con); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; else &#123; println(\" skipping: \" + aDriver.getClass().getName()); &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println(\"getConnection failed: \" + reason); throw reason; &#125; println(\"getConnection: no suitable driver found for \"+ url); throw new SQLException(\"No suitable driver found for \"+ url, \"08001\");&#125; 와 길다~ getConnection 메소드는 여러개로 오버로딩 되어 있으므로 가장 중요한 getConnection만 보면 될 것 같다. 중간에 잘 찾아보면 registerDriver 메소드에서 봤던 registeredDrivers 변수가 보인다. for-loop을 돌면서 driver 오브젝트를 이용해 connect 메소드를 호출해 실질적인 Connection 오브젝트를 생성한다. 이후부터는 생성된 Connection 오브젝트를 가지고 Statement를 만들고 ResultSet도 만들고 하면서 DB에 왔다갔다 하면 된다. ㅋ(JDBC 4.0 스펙부터는 굳이 Class.forName()으로 클래스 로딩 안해도 된다고 한다…) 결론신기술을 배우자. 그리고 적용하자.","categories":[{"name":"Java","slug":"Java","permalink":"https://seunghun-kim.github.io/categories/Java/"},{"name":"JDBC","slug":"Java/JDBC","permalink":"https://seunghun-kim.github.io/categories/Java/JDBC/"}],"tags":[{"name":"java","slug":"java","permalink":"https://seunghun-kim.github.io/tags/java/"},{"name":"jdbc","slug":"jdbc","permalink":"https://seunghun-kim.github.io/tags/jdbc/"}]},{"title":"잡담(1)","slug":"todays-small-talk","date":"2016-10-05T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2016/10/06/todays-small-talk/","link":"","permalink":"https://seunghun-kim.github.io/2016/10/06/todays-small-talk/","excerpt":"","text":"최근 자바스크립트를 공부하려고 책을 하나 구입했다.원래 자바를 위주로 개발을 했지만과거에는 웹에서 이벤트 처리용으로만 사용했던 자바스크립트가서버사이드, 클라이언트 등 광범위하게 사용된다는 이야기를 보고(대세이기도 하고 ㅎ)갑자기 공부를 하고 싶어졌다. 그.런.데.당분간 자바스크립트는 좀 미뤄둬야 할 것 같다.회사에서 자바를 이용해서 처리해야 할 큰 프로젝트가 생겼다.예전에 보던 Eclipse RCP와 SWT/JFace 관련 서적을 다시 봐봐야 할 것 같다.(한번 할 때 제대로 공부하지 못한게 너무 후회된다) 결론무언가를 시도할 때는 끝을 보자!","categories":[],"tags":[]},{"title":"jekyll과 github pages 연동 (1)","slug":"blog_env","date":"2016-10-04T15:00:00.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2016/10/05/blog_env/","link":"","permalink":"https://seunghun-kim.github.io/2016/10/05/blog_env/","excerpt":"","text":"잡담다른 분들의 블로그를 보고 jekyll과 github pages를 이용해서 블로그를 만들었다.블로그에 대해 초짜라 뭐부터 해야할지 몰라서일단은 블로그를 구성하다가 발생한 이슈들을 정리해고자 포스팅을 하기로 했다. 첫 번째 난관 - 의존성 문제가장 먼저 만난 문제는 github pages와의 dependencies 문제이다.github의 Dependency versions 부분을 들어가면 현재 github pages와의 dependencies가 잘 나와있다.처음부터 이걸 기준으로 jekyll을 설치했어야 했는데…일단은 안전하게 가보자! 란 마인드로 여기 페이지의 방법을 그대로 따라했다.(굉장히 정리가 잘 되있어서 너무 감사합니다!) 그 결과, 아무런 문제도 없이 jekyll 수행도 되고 로컬에서 내 블로그도 잘 보였다.기분 좋게 commit 하고 push 하고 나니… 이상한 메일을 하나 받았다. 123456789The page build completed successfully, but returned the following warning:You are currently using the &apos;redcarpet&apos; Markdown engine, which is no longer supported by GitHub Pages and may cease working at any time. To ensure your site continues to build, remove the &apos;markdown&apos; setting in your sites &apos;_config.yml&apos; file and confirm your site renders as expected. For more information, see https://help.github.com/articles/updating-your-markdown-processor-to-kramdown.For information on troubleshooting Jekyll see: https://help.github.com/articles/troubleshooting-jekyll-buildsIf you have any questions you can contact us by replying to this email. 헐 ㅋ redcarpet은 더 이상 지원하지 않는단다.그리고 또 하나! 123456789The page build completed successfully, but returned the following warning:You are attempting to use the &apos;pygments&apos; highlighter, which is currently unsupported on GitHub Pages. Your site will use &apos;rouge&apos; for highlighting instead. To suppress this warning, change the &apos;highlighter&apos; value to &apos;rouge&apos; in your &apos;_config.yml&apos; and ensure the &apos;pygments&apos; key is unset. For more information, see https://help.github.com/articles/page-build-failed-config-file-error/#fixing-highlighting-errors.For information on troubleshooting Jekyll see: https://help.github.com/articles/troubleshooting-jekyll-buildsIf you have any questions you can contact us by replying to this email. pygments도 rouge로 바꾸라고 그런다. 이런거 받으면 기분이 안좋으니깐… 바로 _config.yml 에서 markdown을 kramdown으로, highlighter를 rouge로 바꾸고 jekyll을 다시 돌렸다. 이때 gem install kramdown, gem install rouge 를 통해 설치했는데… 이상한 버전이 설치됬었다.그러니깐 highlighter가 정상적으로 작동을 하지 않던…. 암튼 그래서 Gemfile을 다시 작성했다. 역시 여기에 정보들을 copy &amp; paste 했다. 근데 이건 또 뭐지? 12345678910hun-mac-mini:haddm.github.io hun$ jekyll serve --watchConfiguration file: /Users/hun/git/blog/haddm.github.io/_config.yml Source: /Users/hun/git/blog/haddm.github.io Destination: /Users/hun/git/blog/haddm.github.io/_site Incremental build: disabled. Enable with --incremental Generating... Dependency Error: Yikes! It looks like you don&apos;t have classifier-reborn or one of its dependencies installed. In order to use Jekyll as currently configured, you&apos;ll need to install this gem. The full error message from Ruby is: &apos;cannot load such file -- classifier-reborn&apos; If you run into trouble, you can find helpful resources at http://jekyllrb.com/help/! ERROR: YOUR SITE COULD NOT BE BUILT: ------------------------------------ classifier-reborn classifier-reborn???ruby를 몰라서 google에 폭풍 검색…잘 안나왔다.일단 gem install classifier-reborn 을 통해 설치를 한번 해봤다.?! 설치가 되네 123456hun-mac-mini:haddm.github.io hun$ gem install classifier-rebornFetching: classifier-reborn-2.0.4.gem (100%)Successfully installed classifier-reborn-2.0.4Parsing documentation for classifier-reborn-2.0.4Done installing documentation for classifier-reborn after 0 seconds1 gem installed 그럼 다시 jekyll을 돌려보자! 12345678910hun-mac-mini:haddm.github.io hun$ jekyll serve --watchConfiguration file: /Users/hun/git/blog/haddm.github.io/_config.yml Source: /Users/hun/git/blog/haddm.github.io Destination: /Users/hun/git/blog/haddm.github.io/_site Incremental build: disabled. Enable with --incremental Generating... Dependency Error: Yikes! It looks like you don&apos;t have classifier-reborn or one of its dependencies installed. In order to use Jekyll as currently configured, you&apos;ll need to install this gem. The full error message from Ruby is: &apos;cannot load such file -- classifier-reborn&apos; If you run into trouble, you can find helpful resources at http://jekyllrb.com/help/! ERROR: YOUR SITE COULD NOT BE BUILT: ------------------------------------ classifier-reborn 결과는 똑같았다. 다시 열심히 구글링!stackoverflow에서 답변을 찾았다. (우왕 굳) 먼저 Gemfile 마지막 부분에 추가로 다음 2줄을 입력했다. 12gem &apos;classifier&apos;, &apos;1.3.4&apos;gem &apos;classifier-reborn&apos;, &apos;2.0.4&apos; 그리고는 다음 명령어를 순서대로 수행! 123gem install bundlerrm Gemfile.lockbundle install 그러고 나서 jekyll을 수행! 123456789101112hun-mac-mini:haddm.github.io hun$ jekyll serve --watchConfiguration file: /Users/hun/git/blog/haddm.github.io/_config.yml Source: /Users/hun/git/blog/haddm.github.io Destination: /Users/hun/git/blog/haddm.github.io/_site Incremental build: disabled. Enable with --incremental Generating... Build Warning: Layout &apos;none&apos; requested in feed.xml does not exist. done in 0.213 seconds. Auto-regeneration: enabled for &apos;/Users/hun/git/blog/haddm.github.io&apos;Configuration file: /Users/hun/git/blog/haddm.github.io/_config.yml Server address: http://127.0.0.1:4000/ Server running... press ctrl-c to stop. 우왕 굳! 잘 됬다.(warning은 이유를 찾아봐야겠지만…) 결론구글링과 stackoverflow는 짱짱맨 얼른 댓글이랑 이것저것 추가하는 방법을 알아봐야겠다.","categories":[{"name":"Tips","slug":"Tips","permalink":"https://seunghun-kim.github.io/categories/Tips/"},{"name":"jekyll","slug":"Tips/jekyll","permalink":"https://seunghun-kim.github.io/categories/Tips/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://seunghun-kim.github.io/tags/jekyll/"}]},{"title":"brute_force","slug":"brute_force","date":"2016-03-11T05:03:54.000Z","updated":"2017-11-15T14:45:44.000Z","comments":true,"path":"2016/03/11/brute_force/","link":"","permalink":"https://seunghun-kim.github.io/2016/03/11/brute_force/","excerpt":"","text":"잡담요즘 이슈인 “이세돌 vs AlphaGo”에 관한 기사를 찾아 보다가 아래와 같은 기사를 보았다. “모든 경우의 수를 다 탐색하는 알고리즘인 브루트 포스(Brute force)를 일종의 ‘훈수꾼’으로 사용해 100% 승리할 수밖에 없다.” (출처 : http://www.huffingtonpost.kr/) 보다보니깐 브루트 포스 알고리즘이 무얼까 궁금해서 한번 찾아봤다. 요 알고리즘은 어떻게 돌아갈까? 짜잔. 정의는 아래와 같다. “길이가 n인 텍스트 T에서 길이가 m인 패턴 P를 찾는 간단한 방법” 그럼 이게 무슨 말일까? 예를 보자. 이게 과연 예일까? T는 아래와 같은 문자열을 포함한 텍스트다. 0 0 0 1 0 0 1 0 1 1 1 0 1 … 0 0 1 P의 패턴이 1 0 1 이라고 하면 T에서 1 0 1 이라는 패턴을 찾는 것이 포인트다! 정의를 그저 길게 쓴 느낌인데? 얘는 이렇게 동작한다고 한다. P의 시작 패턴을 T에서 순차적으로 검색 일치하는 패턴이 나오면 T의 연속된 다음 텍스트와 P의 다음 패턴을 비교 일치하는 패턴이 안나오면 T의 연속된 다음 텍스트와 P의 첫 번째 패턴을 비교 2번, 3번 반복 왠지 알고리즘 수업시간에 본 것 같은 알고리즘이다. 바로… sequential search!! O(n)인 아주 단순한 알고리즘이다. 패턴이라는 것만 빼면 같은데?? 그럼 Brute-Force 알고리즘의 복잡도는 어떻게 될까? 복잡도 계산법은 알고리즘 수업 시험을 봄과 동시에 머리에서 GC되서 기억이 안난다… 이런 경우가 최악이라고 한다. T: 0 0 0 0 0 … 0 0 0 1 일 때 P: 0 0 0 1 일 경우 즉, O(nm) 이 된다. AlphaGo가 정말 Brute-Force 알고리즘을 이용하는지는 잘 모르겠지만 오늘 새로운 알고리즘을 하나 알게되서 신난다. 구현은 각자 좋아하는 언어로 해보는게 좋겠다. (참고 : http://glocalit.skhu.ac.kr/~mckim1/Lecture/DS/dna/class12/class12_02.html#Top)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://seunghun-kim.github.io/categories/Algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://seunghun-kim.github.io/tags/Algorithms/"},{"name":"Brute_force","slug":"Brute-force","permalink":"https://seunghun-kim.github.io/tags/Brute-force/"}]}]}